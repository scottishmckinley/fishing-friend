<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Angler OS</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --navy:#050b14; --card:#121c2b; --sea:#34e89e; --gold:#f4af1b; --white:#f1f2f6;
      --text:#cbd5e0; --red:#ff4757; --border:#1e293b; --muted:#64748b;
    }

    *{ box-sizing:border-box; }

    body{
      font-family:'Segoe UI',sans-serif;background:var(--navy);
      margin:0;padding:10px;color:var(--text);-webkit-tap-highlight-color:transparent;
    }

    .app-container{max-width:500px;margin:0 auto;padding-bottom:50px;display:none;}

    #authScreen{
      position:fixed;inset:0;background:var(--navy);z-index:9999;
      display:flex;justify-content:center;align-items:center;
    }
    .auth-card{
      background:var(--card);border:2px solid var(--gold);
      padding:30px;border-radius:20px;width:85%;max-width:340px;text-align:center;
    }

    .drawer{display:none;background:var(--card);border:1px solid var(--gold);border-radius:15px;padding:15px;margin-bottom:15px;}
    .card{background:var(--card);border:1px solid var(--border);padding:15px;border-radius:20px;margin-bottom:15px;}
    .intel-card{border:1px solid var(--gold);border-radius:20px;padding:15px;margin-bottom:15px;background:var(--card);}

    .intel-header{color:var(--gold);font-weight:900;margin-bottom:10px;display:flex;align-items:center;gap:8px;font-size:0.9rem;}
    .intel-list{list-style:none;padding:0;margin:0;font-size:0.8rem;color:var(--white);line-height:1.8;margin-bottom:0;}
    .intel-list li::before{content:"‚Ä¢ ";color:var(--gold);font-weight:bold;}

    /* Header with truly centered logo */
    .app-header{
      position:relative;
      display:flex;
      align-items:center;
      margin-bottom:12px;
      min-height:42px;
      gap:8px;
    }
    .header-left,.header-right{display:flex;gap:8px;z-index:1;}
    .header-right{margin-left:auto;}
    .header-center{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      pointer-events:none;
    }
    .app-logo{
      font-size:1.2rem;
      font-weight:900;
      color:var(--white);
      letter-spacing:.5px;
      white-space:nowrap;
    }

    .hud-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;}
    .hud-item{background:var(--card);padding:12px;border-radius:12px;border:1px solid var(--border);text-align:center;}
    .label{font-size:0.65rem;color:var(--muted);text-transform:uppercase;font-weight:900;display:block;margin-bottom:4px;}
    .val{font-size:1.05rem;font-weight:900;color:var(--white);}
    .sub-val{font-size:0.72rem;font-weight:900;display:block;color:var(--sea);margin-top:2px;}
    .sub-val.red{color:var(--red);}

    .btn-main{
      width:100%;background:var(--sea);color:var(--navy);border:none;
      padding:14px;border-radius:12px;font-weight:900;cursor:pointer;margin-bottom:10px;
      font-size:0.9rem;text-transform:uppercase;
    }
    .btn-sub{
      background:var(--card);border:1px solid var(--border);color:var(--gold);
      padding:10px;border-radius:10px;font-size:0.75rem;font-weight:900;cursor:pointer;
    }

    .btn-fav{
      width:44px;min-width:44px;background:var(--card);border:1px solid var(--border);
      color:var(--gold);border-radius:10px;font-size:1rem;font-weight:900;cursor:pointer;line-height:1;
    }
    .btn-fav.active{background:var(--gold);color:var(--navy);border-color:var(--gold);}
    .btn-fav.disabled{background:#2a3344;color:#7b879d;border-color:#2a3344;cursor:not-allowed;}

    input,select,textarea{
      width:100%;padding:12px;margin-bottom:8px;border:1px solid var(--border);
      border-radius:10px;background:var(--navy);color:var(--white);
    }
    #map{height:180px;border-radius:15px;border:1px solid var(--border);margin-bottom:15px;cursor:crosshair;}

    #toast{
      visibility:hidden;min-width:250px;background:var(--gold);color:var(--navy);
      text-align:center;border-radius:10px;padding:15px;position:fixed;z-index:100000;
      left:50%;bottom:20px;transform:translateX(-50%);font-weight:900;
    }
    #toast.show{visibility:visible;}

    .catch-meta{font-size:0.65rem;color:var(--muted);margin-top:6px;display:grid;grid-template-columns:1fr 1fr;gap:5px;}
    .thumb{width:100%;border-radius:12px;border:1px solid var(--border);margin-top:10px;cursor:pointer;}
    .pb{border:1px solid var(--gold)!important;box-shadow:0 0 0 1px rgba(244,175,27,0.15);}
    .pb-badge{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:999px;background:rgba(244,175,27,0.15);color:var(--gold);font-size:0.65rem;font-weight:900;}

    .cal-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:8px;text-align:center;}
    .cal-day{aspect-ratio:1;display:flex;align-items:center;justify-content:center;font-size:0.8rem;border-radius:10px;cursor:pointer;position:relative;color:var(--text);background:var(--navy);}
    .cal-day.has-catch::after{content:'';width:6px;height:6px;background:var(--sea);border-radius:50%;position:absolute;bottom:4px;}
    .cal-day.selected{background:var(--sea);color:var(--navy);font-weight:900;}

    .tide-table{width:100%;border-collapse:collapse;font-size:0.78rem;}
    .tide-table th,.tide-table td{padding:8px 6px;border-bottom:1px solid var(--border);vertical-align:top;}
    .tide-table th{color:var(--gold);text-align:left;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.04em;}
    .day-row{color:var(--white);font-weight:900;padding-top:10px;}

    .inline-actions{display:flex;flex-direction:column;gap:6px;}
    .edit-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;}

    /* Modal */
    #modalOverlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.65);z-index:200000;justify-content:center;align-items:center;padding:12px;}
    #modal{width:100%;max-width:480px;background:var(--card);border:1px solid var(--gold);border-radius:16px;padding:14px;}
    #modalTop{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px;}
    #modalTitle{margin:0;color:var(--white);font-size:1rem;font-weight:900;}
    #modalClose{background:none;border:none;color:var(--gold);font-weight:900;font-size:1.2rem;cursor:pointer;}

    .muted{opacity:0.7}
  
    /* Photo picker: use camera icon instead of "Choose file" */
    .photo-input{display:none;}
    .photo-actions{display:flex; gap:10px; align-items:center;}
    .photo-btn{
      display:flex;align-items:center;justify-content:center;
      height:44px; width:52px;
      border:1px solid var(--border);
      border-radius:10px;
      background:var(--navy);
      color:var(--gold);
      font-size:1.25rem;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      flex: 0 0 auto;
    }
    .photo-btn:active{transform:scale(.99);}

  
    /* Session bar */
    .session-bar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      background:rgba(18,28,43,.95);
      border:1px solid var(--gold);
      border-radius:14px;
      padding:10px 12px;
      margin-bottom:12px;
    }
    .session-left{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .session-title{font-weight:900; color:var(--white); font-size:0.85rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .session-sub{font-weight:900; color:var(--muted); font-size:0.7rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .session-actions{display:flex; gap:8px; flex:0 0 auto;}
    .btn-pill{
      border:1px solid var(--border);
      background:var(--navy);
      color:var(--gold);
      padding:9px 10px;
      border-radius:999px;
      font-size:0.72rem;
      font-weight:900;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn-pill.red{border-color:var(--red); color:var(--red);}
    
  
    /* Header spacing fix */
    .header{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .header-left{flex:0 0 auto;}
    .header-center{flex:1 1 auto; text-align:center; padding:0 84px;} /* room for right buttons */
    .header-right{flex:0 0 auto; display:flex; gap:8px; align-items:center;}
    @media (max-width: 420px){
      .header-center{padding:0 72px;}
      #helpBtn{padding:10px 10px; min-width:auto;}
      #totalsBtn{padding:10px 10px;}
    }
    
  
    /* Modal scroll fix */
    .modal{
      max-height: 90vh;
      overflow: hidden;
    }
    .modal-content{
      max-height: 90vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .modal-header{
      position: sticky;
      top: 0;
      background: var(--navy);
      z-index: 2;
    }
    .modal-close{
      background:none;
      border:none;
      color:var(--gold);
      font-size:1.2rem;
      font-weight:900;
      cursor:pointer;
    }

    /* Modal fit + scroll (IDs) */
    #modal{
      max-height: 90vh;
      overflow: hidden;
    }
    #modalTop{
      position: sticky;
      top: 0;
      background: var(--navy);
      z-index: 2;
    }
    #modalBody{
      max-height: 78vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 4px;
    }
    
  </style>
</head>

<body>
  <div id="toast">Message</div>

  <div id="authScreen">
    <div class="auth-card">
      <h2 style="color:var(--white); margin-top:0;">ANGLER<span style="color:var(--sea)">OS</span></h2>
      <input type="email" id="loginEmail" placeholder="Email Address" />
      <input type="password" id="loginPass" placeholder="Password" />
      <button class="btn-main" id="loginBtn">LOG IN</button>
    </div>
  </div>

  <div class="app-container" id="mainApp">
    <!-- Header -->
    <div class="app-header">
      <div class="header-left">
        <button class="btn-sub" style="border-color:var(--red); color:var(--red);" id="logoutBtn">LOGOUT</button>
        <button class="btn-sub" id="aboutBtn">‚ÑπÔ∏è ABOUT</button>
      </div>

      <div class="header-center">
        <span class="app-logo">ANGLER<span style="color:var(--sea)">OS</span></span>
      </div>

      <div class="header-right">
        <button class="btn-sub" id="helpBtn" title="Help" style="white-space:nowrap;">‚ùì</button>
        <button class="btn-sub" id="totalsBtn" title="Session summary" style="white-space:nowrap;">üß≠ SESSION: 0</button>
      </div>
    </div>


    <!-- Session bar -->
    <div id="sessionBar" class="session-bar" aria-label="Session controls">
      <div class="session-left">
        <div id="sessionTitle" class="session-title">No active session</div>
        <div id="sessionSub" class="session-sub">Tap START to begin (auto-starts when you save your first catch).</div>
      </div>
      <div class="session-actions">
        <button class="btn-pill" id="sessionStartBtn">‚ñ∂Ô∏è START</button>
        <button class="btn-pill red" id="sessionEndBtn">‚èπ END</button>
      </div>
    </div>

    <!-- Session summary drawer -->
    <div id="totalsBox" class="drawer">
      <div class="intel-header">üß≠ SESSION SUMMARY</div>
      <div id="totalsSummary" class="muted">No active session.</div>

    </div>

    <!-- Favourites -->
    <button class="btn-sub" style="width:100%; margin-bottom:10px;" onclick="toggle('favBox')">‚≠ê FAVOURITES</button>
    <div id="favBox" class="drawer"><div id="favList"></div></div>

    <!-- My intel -->
    <div class="intel-card">
      <div class="intel-header" style="justify-content:space-between; width:100%;">
        <span>üß† MY INTEL</span>
        <select id="intelRange" style="width:auto; padding:8px 10px; margin:0; font-size:0.75rem; font-weight:900;">
          <option value="7">Last 7 days</option>
          <option value="30" selected>Last 30 days</option>
          <option value="90">Last 90 days</option>
          <option value="all">All-time</option>
        </select>
      </div>
      <div id="intelRangeMeta" class="muted" style="font-size:0.72rem; margin-top:-6px; margin-bottom:8px;"></div>
      <div id="myIntelBody" class="muted" style="line-height:1.55;">
        Select a port to see patterns from your catches.
      </div>
    </div>

    <div id="map"></div>

    <button class="btn-main" id="gpsSyncBtn">üìç Find Nearest Port</button>

    <div class="card" style="padding:10px;">
      <div style="display:flex; gap:5px;">
        <input type="text" id="pSearch" placeholder="Search ports..." style="margin:0;" />
        <button class="btn-fav" id="addFavBtn" title="">‚≠ê</button>
      </div>
      <select id="portList" style="margin-top:8px;"></select>
    </div>

    <div class="hud-grid">
      <div class="hud-item">
        <span class="label">Tide</span>
        <div id="hTide" class="val">--</div>
        <span id="hTideD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Flow</span>
        <div id="hFlow" class="val">--</div>
        <span id="hFlowD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Pressure</span>
        <div id="hPress" class="val">--</div>
        <span id="hPressD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Moon</span>
        <div id="hMoon" class="val">--</div>
        <span id="hMoonD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Bite</span>
        <div id="hBite" class="val">--</div>
        <span id="hBiteD" class="sub-val">--</span>
      </div>


      <div class="hud-item">
        <span class="label">Weather</span>
        <div id="hCond" class="val">--</div>
        <span id="hWind" class="sub-val">--</span>
        <span id="hGust" class="sub-val red" style="display:none;">--</span>
      </div>
    </div>

    <button class="btn-sub" style="width:100%; margin-bottom:15px;" onclick="toggle('tideBox')">üåô 7-DAY TIDES</button>
    <div id="tideBox" class="drawer">
      <div class="intel-header">üåô 7-DAY TIDE OUTLOOK</div>
<div id="tideOutlook" class="muted">Select a port to load tides.</div>
    </div>

    <div class="card">
      <div class="edit-grid">
        <input type="text" id="sp" placeholder="Species" style="margin:0;">
        <input type="number" id="wt" placeholder="Weight (lb)" style="margin:0;">
      </div>
      <div class="edit-grid">
        <input type="number" id="len" placeholder="Length (cm)" style="margin:0;">
        <div class="photo-actions">
  <input type="file" id="photo" class="photo-input" accept="image/*">
  <label for="photo" class="photo-btn" title="Add photo" aria-label="Add photo">üì∑</label>
</div>
      </div>
      <textarea id="notes" placeholder="Notes..." style="margin-top:8px; height:70px;"></textarea>
      <button class="btn-main" id="saveBtn">üíæ SAVE RECORD</button>
    </div>

    <div class="card">
      <div class="intel-header">HISTORY CALENDAR</div>
      <div class="cal-grid" id="calGrid"></div>
    </div>

    <div id="diary"></div>
  </div>

  <!-- Modal overlay (About / image preview) -->
  <div id="modalOverlay">
    <div id="modal">
      <div id="modalTop">
        <h3 id="modalTitle">Modal</h3>
        <button id="modalClose" aria-label="Close">‚úï</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, query, where, deleteDoc, doc, orderBy, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDICIj5QIcCLhrq_tlC0QsLKwpB4T7CkoU",
      authDomain: "angleros.firebaseapp.com",
      projectId: "angleros",
      storageBucket: "angleros.firebasestorage.app",
      messagingSenderId: "471426311094",
      appId: "1:471426311094:web:25c0b54a6e1fa7a42e5717"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const AD_KEY = '05819e75195f4d5f8e73742dd5d57c39';
    const PROXY = "https://corsproxy.io/?";

    let catches = [];
    let allPorts = [];
    let favs = JSON.parse(localStorage.getItem('aos_favs')) || [];
    let map, marker;
    let selectedDate = "";
    let userSelectedDate = false;

    

    let currentUid = null;

    let envData = { id:"", port:"Unknown", press:"--", temp:"--", wind:"--", gust:"", weather:"--", tide:"--", flow:"--", tideDir:"--", tideETA:"--" };

    // Tide cache for monthly view
    const tideCache = { portId: null, events: [], fetchedAt: 0 };


    function notify(m) {
      const t = document.getElementById("toast");
      t.innerText = m;
      t.className = "show";
      setTimeout(() => (t.className = ""), 3200);
    }
    window.notify = notify;

    function escapeHtml(str) {
      return (str ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function toggle(id) {
      const e = document.getElementById(id);
      e.style.display = e.style.display === 'block' ? 'none' : 'block';
    }
    window.toggle = toggle;

    // ===== Modal =====
    const modalOverlay = document.getElementById('modalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    document.getElementById('modalClose').onclick = () => closeModal();
    modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) closeModal(); });

    function openModal(title, html) {
      modalTitle.innerText = title;
      modalBody.innerHTML = html;
      modalOverlay.style.display = "flex";
      document.getElementById('modalClose')?.addEventListener('click', closeModal);

    }
    function closeModal() {
      modalOverlay.style.display = "none";
      modalBody.innerHTML = "";
    }
    window.openModal = openModal;

    // ===== Date helpers =====
    function dStr(ms){
      const now = new Date(ms);
      return `${String(now.getDate()).padStart(2,'0')}/${String(now.getMonth()+1).padStart(2,'0')}/${now.getFullYear()}`;
    }
    function todayStr(){
      return dStr(Date.now());
    }

    function fmtDuration(ms) {
      const s = Math.max(0, Math.floor(ms/1000));
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      if (h <= 0) return `${m}m`;
      return `${h}h ${m}m`;
    }

    // ===== Weather helpers =====
    function degToDir(deg) {
      if (typeof deg !== "number") return "--";
      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
      return dirs[Math.round(deg/22.5) % 16];
    }
    function weatherCodeToText(code) {
      const map = {
        0:"Clear", 1:"Mainly clear", 2:"Partly cloudy", 3:"Overcast",
        45:"Fog", 48:"Rime fog",
        51:"Light drizzle", 53:"Drizzle", 55:"Heavy drizzle",
        56:"Freezing drizzle", 57:"Heavy freezing drizzle",
        61:"Light rain", 63:"Rain", 65:"Heavy rain",
        66:"Freezing rain", 67:"Heavy freezing rain",
        71:"Light snow", 73:"Snow", 75:"Heavy snow",
        77:"Snow grains",
        80:"Rain showers", 81:"Heavy showers", 82:"Violent showers",
        85:"Snow showers", 86:"Heavy snow showers",
        95:"Thunderstorm", 96:"Thunderstorm + hail", 99:"Thunderstorm + heavy hail"
      };
      return map[code] ?? "‚Äî";
    }

    // ‚úÖ Proper Earth distance (meters)
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (v) => (v * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function nearestPort(lat, lon) {
      if (!allPorts.length) return null;
      let best = null;
      let bestDist = Infinity;
      for (const p of allPorts) {
        const d = haversineMeters(lat, lon, p.lat, p.lon);
        if (d < bestDist) { bestDist = d; best = p; }
      }
      if (best) best._distMeters = bestDist;
      return best;
    }

    // ===== Ports loading + search =====
    async function loadPorts() {
      const s = document.getElementById('portList');
      s.innerHTML = "";

      const placeholder = document.createElement('option');
      placeholder.value = "";
      placeholder.textContent = "Please select a port...";
      placeholder.disabled = true;
      placeholder.selected = true;
      s.appendChild(placeholder);

      const r = await fetch(PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations?subscription-key=${AD_KEY}`));
      const d = await r.json();

      allPorts = (d?.features || [])
        .map(f => ({
          id: String(f.properties.Id),
          name: f.properties.Name,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0]
        }))
        .sort((a,b) => a.name.localeCompare(b.name));

      allPorts.forEach(p => {
        const o = document.createElement('option');
        o.value = p.id;
        o.textContent = p.name;
        s.appendChild(o);
      });

      const search = document.getElementById('pSearch');
      search.oninput = () => {
        const q = search.value.trim().toLowerCase();
        let visible = 0;
        let firstMatch = null;
        let lastMatch = null;

        [...s.options].forEach((opt, idx) => {
          if (idx === 0) return;
          const ok = !q || opt.textContent.toLowerCase().includes(q);
          opt.hidden = q && !ok;
          if (ok) {
            visible++;
            if (!firstMatch) firstMatch = opt;
            lastMatch = opt;
          }
        });

        // Show "suggestions" by expanding the select into a short list while typing
        if (q) {
          s.size = Math.min(7, Math.max(2, visible + 1)); // +1 for the placeholder row
        } else {
          s.size = 0;
        }

        // If there's exactly one match, auto-select it (but don't auto-load on every keystroke unless it's unique)
        if (q && visible === 1 && firstMatch && firstMatch.value) {
          s.value = firstMatch.value;
        }
      };

      // Keyboard helpers: Enter selects the current/first match, ArrowDown jumps into the list
      search.onkeydown = (e) => {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          s.focus();
          return;
        }
        if (e.key === 'Enter') {
          e.preventDefault();
          // If something is selected, confirm it
          const v = s.value;
          if (v) {
            s.dispatchEvent(new Event('change'));
            resetPortSearchUI();
            search.blur();
          }
        }
      };

      // Close suggestion list when leaving the search box
      search.onblur = () => {
        // slight delay to allow click into the list
        setTimeout(() => { try { s.size = 0; } catch {} }, 150);
      };
    }

    function resetPortSearchUI() {
      const search = document.getElementById('pSearch');
      search.value = "";
      const s = document.getElementById('portList');
      [...s.options].forEach((opt, idx) => { if (idx !== 0) opt.hidden = false; });
      try { s.size = 0; } catch {}
    }

    // ===== Favs =====
    function setFavButtonState() {
      const btn = document.getElementById('addFavBtn');
      if (!envData.id) {
        btn.classList.remove('active'); btn.classList.add('disabled');
        btn.disabled = true; btn.title = "";
        return;
      }
      const exists = favs.some(f => String(f.id) === String(envData.id));
      if (exists) {
        btn.classList.remove('active'); btn.classList.add('disabled');
        btn.disabled = true; btn.title = "Already a favourite";
      } else {
        btn.classList.add('active'); btn.classList.remove('disabled');
        btn.disabled = false; btn.title = "Add to favourites";
      }
    }

    function updateFavsUI() {
      document.getElementById('favList').innerHTML = favs.map(f => `
        <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
          <span onclick="handlePort('${f.id}')" style="cursor:pointer">üìç ${escapeHtml(f.name)}</span>
          <span onclick="remFav('${f.id}')" style="color:var(--red); cursor:pointer;">‚úï</span>
        </div>
      `).join('') || `<div class="muted" style="font-size:0.8rem;">No favourites yet.</div>`;
      setFavButtonState();
            renderMyIntel();
renderSessionBar();
      showQuickStartOnce();
    }

    window.remFav = (id) => {
      favs = favs.filter(x => x.id !== id);
      localStorage.setItem('aos_favs', JSON.stringify(favs));
      updateFavsUI();
      notify("Favourite removed");
    };

    // ===== Map =====
    function initMapOnce() {
      if (map) return;
      map = L.map('map').setView([53.6, -0.2], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      map.on('click', (e) => {
        const n = nearestPort(e.latlng.lat, e.latlng.lng);
        if (!n) return;
        resetPortSearchUI();
        document.getElementById('portList').value = String(n.id);
        handlePort(n.id);
        notify(`Selected: ${n.name}`);
      });
    }

    // ===== Flow / Pressure trend =====
    function classifyFlow(flowStr) {
      const n = parseFloat(String(flowStr).replace("kn",""));
      if (!isFinite(n)) return { label: "‚Äî", ok:false };
      if (n >= 1.5 && n <= 3.0) return { label: "Feeding zone", ok:true };
      if (n < 1.5) return { label: "Slow", ok:false };
      return { label: "Fast", ok:false };
    }

    function pressureTrend(portId, current) {
      const key = `aos_press_${portId}`;
      const prev = JSON.parse(localStorage.getItem(key) || "null");
      localStorage.setItem(key, JSON.stringify({ v: current, t: Date.now() }));

      if (!prev || typeof prev.v !== "number") return "‚Äî";
      const delta = current - prev.v;
      if (Math.abs(delta) < 0.5) return "Stable";
      return delta > 0 ? "Rising" : "Falling";
    }

    // ===== Tides outlook =====
    async function renderTideOutlook(portId) {
      const box = document.getElementById('tideOutlook');
      box.innerHTML = `<div class="muted">Loading 7-day tides‚Ä¶</div>`;

      try {
        const tr = await fetch(
          PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${portId}/TidalEvents?duration=7&subscription-key=${AD_KEY}`));
        const td = await tr.json();

        if (!Array.isArray(td) || !td.length) {
          box.innerHTML = `<div class="muted">No tide events returned.</div>`;
          return;
        }

        

        // Also update the main Tide HUD using the same 7‚Äëday data (more reliable than the 1‚Äëday fetch in some environments)
        try {
          const now0 = new Date();
          const events0 = td.map(e => ({...e, _dt:new Date(e.DateTime)})).sort((a,b)=>a._dt-b._dt);
          const next0 = events0.find(e => e._dt > now0);
          if (next0) {
            const type0 = String(next0.EventType || '').replace('Water','');
            const ht0 = (typeof next0.Height === 'number') ? next0.Height.toFixed(1) : "--";
            const eta0 = fmtDuration(next0._dt - now0);
            const dir0 = type0.toLowerCase().includes("high") ? "Rising" : "Falling";
            const a = document.getElementById('hTide');
            const b = document.getElementById('hTideD');
            if (a) a.innerText = `${ht0}m ${type0}`;
            if (b) b.innerText = `${dir0} ‚Äî in ${eta0}`;
          }
        } catch {}

const byDay = new Map();
        for (const e of td) {
          const dt = new Date(e.DateTime);
          const dayKey = dt.toDateString();
          const type = String(e.EventType || '').replace('Water','');
          const height = (typeof e.Height === 'number') ? e.Height.toFixed(1) + "m" : "--";
          const time = dt.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
          if (!byDay.has(dayKey)) byDay.set(dayKey, []);
          byDay.get(dayKey).push({ dt, time, type, height });
        }

        const days = [...byDay.entries()].sort((a,b) => new Date(a[0]) - new Date(b[0]));
        for (const [, list] of days) list.sort((a,b) => a.dt - b.dt);

        let html = `<table class="tide-table">
          <thead><tr><th style="width:28%;">Day</th><th>High</th><th>Low</th></tr></thead><tbody>`;

        for (const [dayKey, list] of days) {
          const dayLabel = new Date(dayKey).toLocaleDateString([], { weekday:'short', day:'2-digit', month:'short' });
          const highs = list.filter(x => x.type.toLowerCase().includes("high")).map(x => `${x.time} <span class="muted">${x.height}</span>`).join("<br>") || "‚Äî";
          const lows  = list.filter(x => x.type.toLowerCase().includes("low")).map(x => `${x.time} <span class="muted">${x.height}</span>`).join("<br>") || "‚Äî";
          html += `<tr>
            <td class="day-row">${dayLabel}</td>
            <td>${highs}</td>
            <td>${lows}</td>
          </tr>`;
        }

        html += `</tbody></table>`;
        box.innerHTML = html;
      } catch (err) {
        console.error(err);
        box.innerHTML = `<div class="muted">Failed to load tides.</div>`;
      }
    }

    // ===== Handle Port =====
    async function handlePort(id) {
      id = String(id);
      const p = allPorts.find(x => String(x.id) === id);
      if (!p) return;

      envData.id = id;
      envData.port = p.name;
      window.currentLat = p.lat;
      window.currentLon = p.lon;

      // ‚úÖ Keep UI in sync regardless of selection method
      resetPortSearchUI();
      const sel = document.getElementById('portList');
      if (sel) sel.value = id;

      initMapOnce();
      map.setView([p.lat, p.lon], 13);
      if (marker) marker.setLatLng([p.lat, p.lon]);
      else marker = L.marker([p.lat, p.lon]).addTo(map);

      setFavButtonState();
      renderSessionBar();
      showQuickStartOnce();

      // Tide next event + ETA + rising/falling approx
      try {
        const tr = await fetch(
          PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${id}/TidalEvents?duration=1&subscription-key=${AD_KEY}`)
        );
        const td = await tr.json();
        const now = new Date();
        const events = Array.isArray(td) ? td.map(e => ({...e, _dt:new Date(e.DateTime)})).sort((a,b)=>a._dt-b._dt) : [];
        const next = events.find(e => e._dt > now);

        if (next) {
          const type = String(next.EventType || '').replace('Water','');
          const ht = (typeof next.Height === 'number') ? next.Height.toFixed(1) : "--";
          const eta = fmtDuration(next._dt - now);
          const dir = type.toLowerCase().includes("high") ? "Rising" : "Falling";
          envData.tideDir = dir;
          envData.tideETA = eta;
          envData.tide = `${ht}m ${type}`;

          document.getElementById('hTide').innerText = `${ht}m ${type}`;
          document.getElementById('hTideD').innerText = `${dir} ‚Äî in ${eta}`;
        } else {
          document.getElementById('hTide').innerText = "--";
          document.getElementById('hTideD').innerText = "--";
        }
      } catch (err) {
        console.error(err);
      }

      // Weather + Pressure + Flow label
      try {
        const wr = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${p.lat}&longitude=${p.lon}&current=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,surface_pressure`);
        const wd = await wr.json();

        const tempC = wd?.current?.temperature_2m;
        const code  = wd?.current?.weather_code;
        const windKmh = wd?.current?.wind_speed_10m;
        const gustKmh = wd?.current?.wind_gusts_10m;
        const windDir = wd?.current?.wind_direction_10m;
        const press = wd?.current?.surface_pressure;

        const tempTxt = (typeof tempC === 'number') ? `${tempC.toFixed(1)}¬∞C` : "--";
        const wxTxt = weatherCodeToText(code);
        const windMph = (typeof windKmh === 'number') ? (windKmh * 0.621371) : NaN;
        const gustMph = (typeof gustKmh === 'number') ? (gustKmh * 0.621371) : NaN;

        const windDirTxt = degToDir(windDir);
        const windTxt = isFinite(windMph) ? `${windDirTxt} ${windMph.toFixed(0)} mph` : "--";
        const gustTxt = isFinite(gustMph) ? `Gusts ${gustMph.toFixed(0)} mph` : "";

        envData.temp = tempTxt;
        envData.weather = wxTxt;
        envData.wind = windTxt;
        envData.gust = gustTxt;

        document.getElementById('hCond').innerText = `${tempTxt} ‚Äî ${wxTxt}`;
        document.getElementById('hWind').innerText = `üí® ${windTxt}`;
        const gustEl = document.getElementById('hGust');
        if (gustTxt) {
          gustEl.style.display = "block";
          gustEl.innerText = `‚ö†Ô∏è ${gustTxt}`;
        } else {
          gustEl.style.display = "none";
        }

        if (typeof press === 'number') {
          const trend = pressureTrend(id, press);
          envData.press = `${press.toFixed(1)} hPa`;
          document.getElementById('hPress').innerText = envData.press;
          document.getElementById('hPressD').innerText = trend;
        } else {
          document.getElementById('hPress').innerText = "--";
          document.getElementById('hPressD').innerText = "--";
        }


        // Moon (current)
        try{
          const mp = moonPhaseInfo(Date.now());
          envData.moon = mp;
          const mEl = document.getElementById('hMoon');
          const mdEl = document.getElementById('hMoonD');
          if (mEl) mEl.innerText = `${mp.emoji} ${mp.name}`;
          if (mdEl) mdEl.innerText = `${mp.illum}% illum ‚Äî age ${mp.ageDays}d`;
          window.currentMoonAgeDays = mp.ageDays;
        } catch {}

        // Flow placeholder (until you swap to a real current API)
        envData.flow = (1.5 + Math.random()).toFixed(1) + "kn";
        const fc = classifyFlow(envData.flow);
        document.getElementById('hFlow').innerText = envData.flow;
        document.getElementById('hFlowD').innerText = fc.ok ? "Feeding zone" : fc.label;

      } catch (err) {
        console.error(err);
      }

      renderTideOutlook(id);
    

      // Refresh My Intel for the selected port
      try { renderMyIntel(); } catch {}
}
    window.handlePort = handlePort;

    // ===== Photo compression (Firestore-friendly) =====
    async function fileToCompressedDataUrl(file, maxW=900, quality=0.72) {
      const img = await new Promise((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = URL.createObjectURL(file);
      });

      const scale = Math.min(1, maxW / img.width);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);

      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);

      URL.revokeObjectURL(img.src);
      return canvas.toDataURL('image/jpeg', quality);
    }

    // ===== PB by WEIGHT only =====
    function computePBMap(items) {
      const best = new Map();
      for (const c of items) {
        const sp = (c.sp || "").toUpperCase();
        const wt = Number(c.wt || 0);
        if (!best.has(sp)) best.set(sp, { wt, id:c.id });
        else if (wt > best.get(sp).wt) best.set(sp, { wt, id:c.id });
      }
      return best;
    }

    // ===== Share =====
    function shareCatch(c) {
      const text =
`AnglerOS Catch Log
Species: ${c.sp || ""}
Weight: ${c.wt || 0} lb
Length: ${c.len || 0} cm
Location: ${c.loc || ""}
Date: ${c.dt || ""} @ ${c.time || ""}
Weather: ${c.weather || ""}, ${c.temp || ""}, Wind ${c.wind || ""} ${c.gust ? "(" + c.gust + ")" : ""}
Pressure: ${c.press || c.baro || ""}
Tide: ${c.tide || ""}
Flow: ${c.flow || ""}
Notes: ${c.notes || ""}`.trim();

      if (navigator.share) {
        navigator.share({ title:"AnglerOS Catch", text }).catch(()=>{});
        return;
      }
      navigator.clipboard?.writeText(text)
        .then(() => notify("Copied to clipboard"))
        .catch(() => notify("Share not supported"));
    }
    window.shareCatchById = (id) => {
      const c = catches.find(x => x.id === id);
      if (c) shareCatch(c);
    };

    // ===== Delete =====
    window.delCatch = async (id) => {
      if (!confirm("Delete record?")) return;
      await deleteDoc(doc(db, "catches", id));
    };

    
    // ===== Session Engine (one active session) =====
    const SessionEngine = (() => {
      const KEY = "aos_sessions_v1";
      const now = () => Date.now();
      const uid = () => (crypto.randomUUID ? crypto.randomUUID() : String(now()) + Math.random().toString(16).slice(2));

      const read = () => { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } };
      const write = (rows) => localStorage.setItem(KEY, JSON.stringify(rows));

      const getActive = () => read().find(s => !s.endAt) || null;

      const start = ({ port="", lat=null, lon=null, acc=null } = {}) => {
        const rows = read().map(s => s.endAt ? s : ({ ...s, endAt: now(), updatedAt: now() })); // auto-end any active
        const s = {
          id: "sess_" + uid(),
          startAt: now(),
          endAt: null,
          port,
          lat, lon, acc,
          createdAt: now(),
          updatedAt: now()
        };
        rows.push(s);
        write(rows);
        return s;
      };

      const end = (id=null) => {
        const rows = read();
        const s = id ? rows.find(x => x.id === id) : rows.find(x => !x.endAt);
        if (!s || s.endAt) return s || null;
        s.endAt = now();
        s.updatedAt = now();
        write(rows);
        return s;
      };

      const ensureActive = (meta={}) => getActive() || start(meta);

      const durationMs = (s) => ( (s.endAt || now()) - s.startAt );
      const durationLabel = (ms) => {
        const mins = Math.max(0, Math.round(ms/60000));
        const h = Math.floor(mins/60), m = mins%60;
        return h ? `${h}h ${m}m` : `${m}m`;
      };

      return { read, write, getActive, start, end, ensureActive, durationMs, durationLabel };
    })();

    function getSessionMetaFromEnv(){
      return {
        port: envData.port || "",
        lat: envData.lat ?? null,
        lon: envData.lon ?? null,
        acc: envData.acc ?? null
      };

      // Refresh My Intel for the selected port
      try { renderMyIntel(); } catch {}

    }

    function formatLocal(dt){
      try {
        return new Date(dt).toLocaleString([], { year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });
      } catch { return ""; }
    }

    function buildSessionSummaryHtml() {
      const s = SessionEngine.getActive();
      if (!s) return `<div class="muted">No active session. Press <b>START SESSION</b> or save a catch to auto-start.</div>`;

      // Use in-memory catches array filtered by sessionId (if present)
      const sessionCatches = catches.filter(c => c.sessionId === s.id);
      const totalCount = sessionCatches.length;
      const totalWeight = sessionCatches.reduce((sum, c) => sum + (Number(c.wt)||0), 0);

      const bySpecies = {};
      for (const c of sessionCatches) {
        const k = (c.sp || "UNKNOWN").toUpperCase();
        bySpecies[k] = (bySpecies[k] || 0) + 1;
      }
      const rows = Object.entries(bySpecies)
        .sort((a,b)=>b[1]-a[1])
        .map(([sp,n]) => `<div class="row" style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);">
          <div><b>${escapeHtml(sp)}</b></div><div>${n}</div>
        </div>`).join("");

      return `
        <div class="card" style="padding:10px;">
          <div><b>Session:</b> ${escapeHtml(s.port || "‚Äî")}</div>
          <div><b>Start:</b> ${escapeHtml(formatLocal(s.startAt))}</div>
          <div><b>Duration:</b> ${escapeHtml(SessionEngine.durationLabel(SessionEngine.durationMs(s)))}</div>
          <div style="margin-top:6px;"><b>Total caught:</b> ${totalCount}</div>
          <div><b>Total weight:</b> ${totalWeight.toFixed(1)} lb</div>
        </div>
        <div style="margin-top:10px;">
          <div class="intel-header" style="margin:0 0 6px;">Species breakdown</div>
          ${rows || `<div class="muted">No catches in this session yet.</div>`}
        </div>
      `;
    }

    function updateSessionBadge(){
      const s = SessionEngine.getActive();
      const n = s ? catches.filter(c => c.sessionId === s.id).length : 0;
      const btn = document.getElementById('totalsBtn');
      if (btn) btn.textContent = `üß≠ SESSION: ${n}`;
    }


    function renderSessionBar(){
      const s = SessionEngine.getActive();
      const titleEl = document.getElementById('sessionTitle');
      const subEl = document.getElementById('sessionSub');
      const startBtn = document.getElementById('sessionStartBtn');
      const endBtn = document.getElementById('sessionEndBtn');

      if (!titleEl || !subEl || !startBtn || !endBtn) return;

      if (!s){
        titleEl.innerText = "No active session";
        subEl.innerText = "Tap START to begin (auto-starts when you save your first catch).";
        startBtn.style.display = "inline-flex";
        endBtn.style.display = "none";
        return;
      }

      const count = catches.filter(c => c.sessionId === s.id).length;
      const dur = SessionEngine.durationLabel(SessionEngine.durationMs(s));
      const place = (s.port && s.port !== "Unknown") ? s.port : (envData.port || "Unknown");
      titleEl.innerText = `Session active ‚Äî ${dur}`;
      subEl.innerText = `${place} ‚Äî ${count} catch${count === 1 ? "" : "es"}`;
      startBtn.style.display = "none";
      endBtn.style.display = "inline-flex";
    }

    function helpHtml(){
      return `
        <div style="font-size:0.9rem; line-height:1.65;">
          <div class="intel-header" style="margin-top:0;">Quick start</div>
          <ol style="margin:0 0 12px 18px; padding:0;">
            <li><b>Select a port</b> (or tap <b>Find Nearest Port</b>).</li>
            <li>Tap <b>START</b> in the session bar (or just save your first catch to auto-start).</li>
            <li><b>Save a catch</b> (species, weight/length, optional photo + notes).</li>
            <li>Use the <b>History Calendar</b> to jump to a day‚Äôs catches.</li>
            <li>Tap <b>END</b> when you finish.</li>
          </ol>

          <div class="intel-header">How sessions work</div>
          <ul class="intel-list" style="margin-bottom:12px;">
            <li>Only <b>one active session</b> at a time.</li>
            <li>Sessions are <b>overnight-safe</b> (midnight doesn‚Äôt break totals).</li>
            <li>Your catches are saved automatically.</li>
          </ul>

          <div class="intel-header">What each card shows</div>
          <div style="display:grid; gap:10px; margin-bottom:12px;">
            <div><b>Map & GPS</b><br><span class="muted">Your current location, selected port, and favourites. Use it to set where you‚Äôre fishing.</span></div>
            <div><b>Fishing Intel</b><br><span class="muted">A quick at-a-glance summary for the selected location.</span></div>
            <div><b>Weather</b><br><span class="muted">Forecast and current conditions for the selected port/location.</span></div>
            <div><b>Tide</b><br><span class="muted">Next tide and a 7‚Äëday outlook for the selected port.</span></div>
            <div><b>Flow & Pressure</b><br><span class="muted">Supporting conditions that can affect feeding behaviour.</span></div>
            <div><b>Catch entry</b><br><span class="muted">Log a catch with time/date, details, notes and a photo.</span></div>
            <div><b>Previous catches</b><br><span class="muted">Your recent catch log. Edit or delete entries.</span></div>
            <div><b>History Calendar</b><br><span class="muted">Jump to a specific day to review what you caught.</span></div>
            <div><b>Session Summary</b><br><span class="muted">Totals for the current session (count, duration, breakdown).</span></div>
          </div>

          <div class="intel-header">Tips</div>
          <ul class="intel-list" style="margin-bottom:12px;">
            <li>Use <b>‚òÖ Favourites</b> to save regular marks.</li>
            <li>Tap <b>üß≠ SESSION</b> for a quick summary at any time.</li>
          </ul>

          <div style="margin-top:14px; display:flex; gap:10px;">
            <button class="btn-main" id="helpGotItBtn" style="margin:0;">GOT IT</button>
          </div>
          <div style="margin-top:8px; font-size:0.8rem;" class="muted">
            Tip: Help is always available from the <b>‚ùì</b> button.
          </div>
        </div>
      `;
    }

    // ===== 7-day tide planner =====
    function fmtTimeLocal(dtStr){
      const d = new Date(dtStr);
      return d.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
    }

    function dayKeyFromDate(dt){
      return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
    }

    function groupEventsByDay(events){
      const by = {};
      for (const e of (events || [])){
        if (!e || !e.DateTime) continue;
        const d = new Date(e.DateTime);
        const key = dayKeyFromDate(d);
        (by[key] ||= []).push(e);
      }
      for (const k of Object.keys(by)){
        by[k].sort((a,b)=> new Date(a.DateTime) - new Date(b.DateTime));
      }
      return by;
    }

    function buildPlannerHtml(){
      const by = groupEventsByDay(tideCache.events || []);
      const today = new Date();
      const days = [];
      for (let i=0;i<7;i++){
        const d = new Date(today.getFullYear(), today.getMonth(), today.getDate()+i);
        days.push(d);
      }

      const items = days.map(d => {
        const key = dayKeyFromDate(d);
        const ev = by[key] || [];
        const label = d.toLocaleDateString([], { weekday:'short', day:'2-digit', month:'short' });
        const hw = ev.filter(e => e.EventType === "HighWater").slice(0,2)
          .map(e => `${fmtTimeLocal(e.DateTime)} (${(typeof e.Height==="number"?e.Height.toFixed(1):"--")}m)`).join(" ‚Ä¢ ");
        const lw = ev.filter(e => e.EventType === "LowWater").slice(0,2)
          .map(e => `${fmtTimeLocal(e.DateTime)} (${(typeof e.Height==="number"?e.Height.toFixed(1):"--")}m)`).join(" ‚Ä¢ ");

        const body = ev.length
          ? `<div style="display:grid; gap:6px;">
               <div><b>High:</b> <span class="muted">${hw || "‚Äî"}</span></div>
               <div><b>Low:</b> <span class="muted">${lw || "‚Äî"}</span></div>
             </div>`
          : `<div class="muted">No tide events available.</div>`;

        return `
          <div class="card" style="padding:10px; margin-bottom:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
              <div style="font-weight:900;">${escapeHtml(label)}</div>
              <button class="btn-sub" data-tide-day="${key}" style="padding:8px 10px;">DETAILS</button>
            </div>
            <div style="margin-top:8px;">${body}</div>
          </div>
        `;
      }).join("");

      return `
        <div class="muted" style="margin-bottom:10px;">
          7-day tide planner for <b>${escapeHtml(envData.portName || envData.port || "selected port")}</b>.
        </div>
        ${items}
      `;
    }

    function showTideDayDetail(dateKey){
      const by = groupEventsByDay(tideCache.events);
      const ev = by[dateKey] || [];
      const [y,m,d] = dateKey.split('-').map(Number);
      const nice = new Date(y, m-1, d).toLocaleDateString([], { weekday:'long', year:'numeric', month:'short', day:'2-digit' });

      if (!ev.length){
        openModal("Tides", `<div class="muted">No tide events available for ${escapeHtml(nice)}.</div>`);
        return;
      }

      const rows = ev.map(e => {
        const t = fmtTimeLocal(e.DateTime);
        const h = (typeof e.Height === "number") ? e.Height.toFixed(2) : "--";
        const type = (e.EventType === "HighWater") ? "High" : "Low";
        return `<div class="row" style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,.06);">
          <div><b>${type}</b> ‚Ä¢ ${t}</div><div>${h} m</div>
        </div>`;
      }).join("");

      openModal("Tides ‚Ä¢ " + nice, `<div>${rows}</div>`);
    }

    async function openTidePlanner(){
      // Resolve selected station id
      let portId = envData.portId || envData.id || document.getElementById('portList')?.value || null;
      if (!portId){
        const wanted = (envData.portName || envData.port || "").trim().toLowerCase();
        const sel = document.getElementById('portList');
        if (wanted && sel){
          const opt = Array.from(sel.options || []).find(o => (o.textContent || "").trim().toLowerCase() === wanted);
          if (opt && opt.value) portId = opt.value;
        }
      }
      if (!portId){
        notify("Select a port first");
        return;
      }
      envData.portId = portId;
      envData.id = portId;

      // Ensure cache is fresh (10 minutes)
      if (!tideCache.events?.length || tideCache.portId !== portId || (Date.now() - tideCache.fetchedAt) > 10*60*1000){
        try {
          const url = PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${portId}/TidalEvents?duration=7&subscription-key=${AD_KEY}`);
          const resp = await fetch(url);
          if (!resp.ok){
            const txt = await resp.text();
            console.warn("Tide fetch failed", resp.status, txt.slice(0,200));
            notify("Couldn't load tides");
            return;
          }
          const ctype = resp.headers.get('content-type') || '';
          if (!ctype.includes('application/json')){
            const txt = await resp.text();
            console.warn("Non-JSON tide response", txt.slice(0,200));
            notify("Couldn't load tides");
            return;
          }
          const td = await resp.json();
          tideCache.portId = portId;
          tideCache.events = Array.isArray(td) ? td.slice() : [];
          tideCache.fetchedAt = Date.now();
        } catch (e){
          console.warn(e);
          notify("Couldn't load tides");
          return;
        }
      }

      openModal("7-day planner", buildPlannerHtml());
      setTimeout(() => {
        document.querySelectorAll('[data-tide-day]').forEach(btn => {
          btn.onclick = () => showTideDayDetail(btn.getAttribute('data-tide-day'));
        });
      }, 0);
    }


    function showHelp(){
      openModal("Help", helpHtml());
      setTimeout(() => {
        const b = document.getElementById('helpGotItBtn');
        if (b) b.onclick = () => closeModal();
      }, 0);
    }

    function showQuickStartOnce(){
      const key = "aos_help_seen_v1";
      if (localStorage.getItem(key) === "1") return;
      showHelp();
      setTimeout(() => {
        const b = document.getElementById('helpGotItBtn');
        if (b) b.onclick = () => { localStorage.setItem(key, "1"); closeModal(); };
      }, 0);
    }


    // ===== Inline edit =====
    const editState = new Map();

    window.startEdit = (id) => {
      const c = catches.find(x => x.id === id);
      if (!c) return;
      editState.set(id, { photo: c.photo || "" });
      renderDiary();
    };
    window.cancelEdit = (id) => { editState.delete(id); renderDiary(); };

    window.saveEdit = async (id) => {
      const c = catches.find(x => x.id === id);
      if (!c) return;

      const sp = document.getElementById(`es_${id}`).value.trim();
      const wt = Number(document.getElementById(`ew_${id}`).value || 0);
      const len = Number(document.getElementById(`el_${id}`).value || 0);
      const notes = document.getElementById(`en_${id}`).value || "";
      const staged = editState.get(id) || {};
      const photo = staged.photo ?? (c.photo || "");

      await updateDoc(doc(db, "catches", id), {
        sp: sp.toUpperCase(),
        wt,
        len,
        notes,
        photo,
        updatedAt: Date.now()
      });

      editState.delete(id);
      renderDiary();
      notify("Record updated");
    };

    // ===== Diary =====
    function renderDiary() {
      const list = selectedDate ? catches.filter(c => c.dt === selectedDate) : catches;
      const pbMap = computePBMap(catches);

      document.getElementById('diary').innerHTML = list.map(c => {
        const sp = (c.sp || "").toUpperCase();
        const isPB = pbMap.get(sp)?.id === c.id;
        const editing = editState.has(c.id);
        const staged = editState.get(c.id) || {};
        const photoToShow = staged.photo ?? c.photo ?? "";

        if (!editing) {
          const pbBadge = isPB ? `<span class="pb-badge">PB</span>` : "";
          const photoHtml = photoToShow ? `<img class="thumb" src="${photoToShow}" onclick="openModal('Photo', '<img src=&quot;${photoToShow}&quot; style=&quot;width:100%;border-radius:12px;border:1px solid var(--border);&quot;>')">` : "";

          return `
            <div class="card ${isPB ? "pb" : ""}">
              <div style="display:flex; justify-content:space-between; align-items:start; gap:10px;">
                <div style="flex:1;">
                  <b style="color:var(--sea);">${escapeHtml(sp)}</b>${pbBadge}
                  <div style="margin-top:2px;"><small>${escapeHtml(String(c.wt ?? 0))}lb ‚Äî ${escapeHtml(String(c.len ?? 0))}cm</small></div>
                  <small style="color:var(--gold);">${escapeHtml(c.loc || '--')} | ${escapeHtml(c.dt || '--')} @ ${escapeHtml(c.time || '--:--')}</small>
                </div>

                <div class="inline-actions">
                  <button class="btn-sub" onclick="startEdit('${c.id}')" style="padding:8px;">‚úèÔ∏è Edit</button>
                  <button class="btn-sub" onclick="shareCatchById('${c.id}')" style="padding:8px;">üì§ Share</button>
                  <button class="btn-sub" onclick="delCatch('${c.id}')" style="padding:8px; border-color:var(--red); color:var(--red);">üóëÔ∏è</button>
                </div>
              </div>

              <div class="catch-meta" style="margin-top:10px;">
                <span>üå°Ô∏è ${escapeHtml(c.temp || '--')} ‚Äî ${escapeHtml(c.weather || '--')}</span>
                <span>üí® ${escapeHtml(c.wind || '--')} ${c.gust ? `‚Ä¢ <span style="color:var(--red); font-weight:900;">${escapeHtml(c.gust)}</span>` : ""}</span>
                <span>üß≠ Pressure: ${escapeHtml(c.press || c.baro || '--')}</span>
                <span>üåä Tide: ${escapeHtml(c.tide || '--')}</span>
                <span>üöÄ Flow: ${escapeHtml(c.flow || '--')}</span>
                <span>üìù Notes: ${c.notes ? escapeHtml(c.notes) : '--'}</span>
              </div>

              ${photoHtml}
            </div>
          `;
        }

        return `
          <div class="card ${isPB ? "pb" : ""}">
            <div style="display:flex; justify-content:space-between; align-items:start; gap:10px;">
              <div style="flex:1;">
                <b style="color:var(--sea);">EDIT</b>
                <div class="muted" style="font-size:0.75rem; margin-top:4px;">
                  Original preserved: ${escapeHtml(c.dt || "")} @ ${escapeHtml(c.time || "")}
                </div>
              </div>
              <div class="inline-actions">
                <button class="btn-sub" onclick="cancelEdit('${c.id}')" style="padding:8px;">Cancel</button>
                <button class="btn-sub" onclick="saveEdit('${c.id}')" style="padding:8px; border-color:var(--sea); color:var(--sea);">Save</button>
              </div>
            </div>

            <div class="edit-grid" style="margin-top:12px;">
              <input id="es_${c.id}" value="${escapeHtml(c.sp || "")}" placeholder="Species" />
              <input id="ew_${c.id}" type="number" value="${escapeHtml(String(c.wt ?? 0))}" placeholder="Weight (lb)" />
            </div>
            <div class="edit-grid">
              <input id="el_${c.id}" type="number" value="${escapeHtml(String(c.len ?? 0))}" placeholder="Length (cm)" />
              <div class="photo-actions">
  <input id="ep_${c.id}" type="file" class="photo-input" accept="image/*" />
  <label for="ep_${c.id}" class="photo-btn" title="Replace photo" aria-label="Replace photo">üì∑</label>
</div>
            </div>
            <textarea id="en_${c.id}" style="height:80px;" placeholder="Notes...">${escapeHtml(c.notes || "")}</textarea>

            <div class="muted" style="font-size:0.75rem;">Replace photo (optional). Photos are auto-compressed.</div>
            ${photoToShow ? `<img class="thumb" src="${photoToShow}" onclick="openModal('Photo', '<img src=&quot;${photoToShow}&quot; style=&quot;width:100%;border-radius:12px;border:1px solid var(--border);&quot;>')">` : `<div class="muted" style="font-size:0.8rem; margin-top:10px;">No photo</div>`}
          </div>
        `;
      }).join('') || `<div style="text-align:center; opacity:0.5;">No records</div>`;

      for (const c of list) {
        if (!editState.has(c.id)) continue;
        const input = document.getElementById(`ep_${c.id}`);
        if (!input) continue;
        input.onchange = async () => {
          const file = input.files?.[0];
          if (!file) return;
          const dataUrl = await fileToCompressedDataUrl(file, 900, 0.72);
          editState.set(c.id, { ...(editState.get(c.id)||{}), photo: dataUrl });
          renderDiary();
        };
      }
    }

    // ===== Calendar =====
    function renderCalendar() {
      const g = document.getElementById('calGrid');
      g.innerHTML = "";
      const now = new Date();
      const m = now.getMonth();
      const y = now.getFullYear();
      const first = new Date(y, m, 1).getDay() || 7;
      const total = new Date(y, m + 1, 0).getDate();

      for (let i = 1; i < first; i++) g.appendChild(document.createElement('div'));

      for (let d = 1; d <= total; d++) {
        const dStr = `${String(d).padStart(2,'0')}/${String(m+1).padStart(2,'0')}/${y}`;
        const div = document.createElement('div');
        div.className = `cal-day ${catches.some(c => c.dt === dStr) ? 'has-catch' : ''} ${selectedDate === dStr ? 'selected' : ''}`;
        div.innerText = d;
        div.onclick = () => {
          if (selectedDate === dStr) {
            // Clear selection -> revert to today view
            selectedDate = todayStr();
            userSelectedDate = false;
          } else {
            selectedDate = dStr;
            userSelectedDate = true;
          }
          renderCalendar();
          renderDiary();
        };
        g.appendChild(div);
      }
    }

    // ===== Totals (today only) =====
    function buildTodaySummaryHtml() {
      const dtStr = todayStr();
      const dayCatches = catches.filter(c => c.dt === dtStr);
      const totalCount = dayCatches.length;
      const totalWeight = dayCatches.reduce((sum, c) => sum + Number(c.wt || 0), 0);

      const bySpecies = new Map();
      for (const c of dayCatches) {
        const sp = (c.sp || "UNKNOWN").toUpperCase();
        const obj = bySpecies.get(sp) || { count: 0, weight: 0 };
        obj.count += 1;
        obj.weight += Number(c.wt || 0);
        bySpecies.set(sp, obj);
      }

      const rows = [...bySpecies.entries()]
        .sort((a,b) => b[1].count - a[1].count)
        .map(([sp, v]) => `
          <div style="display:flex; justify-content:space-between; border-bottom:1px solid var(--border); padding:8px 0; font-size:0.85rem;">
            <div><b style="color:var(--sea)">${escapeHtml(sp)}</b> <span class="muted">x${v.count}</span></div>
            <div><span class="muted">${v.weight.toFixed(1)}lb</span></div>
          </div>
        `).join("");

      return `
        <div style="font-size:0.85rem; margin-bottom:8px;">
          <div><b>Date:</b> ${escapeHtml(dtStr)}</div>
          <div style="margin-top:6px;"><b>Total caught:</b> ${totalCount}</div>
          <div><b>Total weight:</b> ${totalWeight.toFixed(1)} lb</div>
        </div>
        <div style="margin-top:10px;">
          <div class="intel-header" style="margin:0 0 6px;">Species breakdown</div>
          ${rows || `<div class="muted">No catches recorded today.</div>`}
        </div>
      `;
    }

    // ===== Save catch =====
    
    // ===== My Intel (personal insights) =====
    function moonPhaseInfo(dateMs){
      // Simple synodic month model (good enough for angling insights)
      const synodic = 29.53058867; // days
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14, 0); // 2000-01-06 18:14 UTC
      const days = (dateMs - knownNewMoon) / 86400000;
      let age = days % synodic;
      if (age < 0) age += synodic;

      const frac = age / synodic; // 0..1
      const idx = Math.floor((frac * 8) + 0.5) % 8; // 8 phases
      const phases = [
        {name:"New Moon", emoji:"üåë"},
        {name:"Waxing Crescent", emoji:"üåí"},
        {name:"First Quarter", emoji:"üåì"},
        {name:"Waxing Gibbous", emoji:"üåî"},
        {name:"Full Moon", emoji:"üåï"},
        {name:"Waning Gibbous", emoji:"üåñ"},
        {name:"Last Quarter", emoji:"üåó"},
        {name:"Waning Crescent", emoji:"üåò"},
      ];
      const p = phases[idx];
      const illum = (1 - Math.cos(2*Math.PI*frac)) / 2; // 0..1
      return { ...p, ageDays: Number(age.toFixed(1)), illum: Math.round(illum*100) };
    }

    function tideContextFor(dateMs, portId){
      try{
        const events = (tideCache && Array.isArray(tideCache.events)) ? tideCache.events : [];
        if (!events.length) return null;
        if (tideCache.portId && portId && tideCache.portId !== portId) return null;

        const t = new Date(dateMs).getTime();
        const parsed = events
          .filter(e => e && e.DateTime)
          .map(e => ({...e, _t: new Date(e.DateTime).getTime()}))
          .filter(e => Number.isFinite(e._t))
          .sort((a,b)=>a._t-b._t);

        if (!parsed.length) return null;

        // Nearest future event
        let next = parsed.find(e => e._t >= t) || null;
        let prev = null;
        for (let i=parsed.length-1;i>=0;i--){
          if (parsed[i]._t <= t){ prev = parsed[i]; break; }
        }
        const nearest = next || prev;
        if (!nearest) return null;

        const minsTo = Math.round((nearest._t - t) / 60000); // + before event, - after event
        const absH = Math.min(6, Math.max(0, Math.floor(Math.abs(minsTo)/60))); // cap at 6h for bucketing
        const bucket = `${nearest.EventType === "HighWater" ? "HW" : "LW"} ${minsTo>=0 ? "-" : "+"}${absH}h`;

        // Rising/falling approximation based on the next event type
        let phase = "Unknown";
        if (next){
          phase = next.EventType === "HighWater" ? "Rising" : "Falling";
        } else if (prev){
          // after last known event, assume heading toward opposite (rough)
          phase = prev.EventType === "HighWater" ? "Falling" : "Rising";
        }

        return {
          phase,
          nearestEventType: nearest.EventType,
          minsToNearestEvent: minsTo,
          bucket,
          height: (typeof nearest.Height === "number") ? nearest.Height : null
        };
      } catch {
        return null;
      }
    }

    
function topN(mapObj, n=2){
      return Object.entries(mapObj).sort((a,b)=>b[1]-a[1]).slice(0,n);
    }

    // ===== My Intel range filter =====
    const INTEL_RANGE_KEY = "aos_intel_range_v1";

    function getIntelRangeValue(){
      const sel = document.getElementById('intelRange');
      const saved = localStorage.getItem(INTEL_RANGE_KEY);
      const val = (sel && sel.value) ? sel.value : (saved || "30");
      return val || "30";
    }

    function applySavedIntelRange(){
      const sel = document.getElementById('intelRange');
      if (!sel) return;
      const saved = localStorage.getItem(INTEL_RANGE_KEY);
      if (saved && Array.from(sel.options).some(o => o.value === saved)) {
        sel.value = saved;
      }
    }

    function intelRangeStartMs(){
      const v = getIntelRangeValue();
      if (v === "all") return null;
      const days = Number(v);
      if (!Number.isFinite(days) || days <= 0) return null;
      return Date.now() - (days * 86400000);
    }

    function formatIntelRangeLabel(){
      const v = getIntelRangeValue();
      if (v === "all") return "All-time";
      const days = Number(v);
      if (!Number.isFinite(days)) return "Last 30 days";
      return `Last ${days} days`;
    }

    function renderIntelRangeMeta(){
      const meta = document.getElementById('intelRangeMeta');
      if (!meta) return;
      const v = getIntelRangeValue();
      const start = intelRangeStartMs();
      if (v === "all" || !start){
        meta.innerHTML = `Showing <b>${escapeHtml(formatIntelRangeLabel())}</b>.`;
        return;
      }
      const startStr = new Date(start).toLocaleDateString([], { day:'2-digit', month:'short', year:'numeric' });
      const endStr = new Date().toLocaleDateString([], { day:'2-digit', month:'short', year:'numeric' });
      meta.innerHTML = `Showing <b>${escapeHtml(formatIntelRangeLabel())}</b> (${escapeHtml(startStr)} ‚Äì ${escapeHtml(endStr)}).`;
    }

    function catchTimestampMs(c){
      const ts = c?.caughtAt ?? c?.timestamp ?? c?.createdAt;
      const n = Number(ts);
      return Number.isFinite(n) ? n : null;
    }

    function filterCatchesByIntelRange(list){
      const start = intelRangeStartMs();
      if (!start) return list;
      return list.filter(c => {
        const ts = catchTimestampMs(c);
        return ts ? ts >= start : false;
      });
    }

    function renderMyIntel(){
      const el = document.getElementById('myIntelBody');
      if (!el) return;

      renderIntelRangeMeta();

      const portName = (envData.port || "").trim();
      const portId = envData.id || envData.portId || null;

      if (!portName){
        el.innerHTML = "Select a port to see patterns from your catches.";
        return;
      }

      const pn = (portName || '').trim().toLowerCase();
      const atPortAll = catches.filter(c => {
        const cid = (c.portId || c.idPort || c.stationId || '').toString();
        if (portId && cid && cid === String(portId)) return true;
        const cl = (c.loc || '').trim().toLowerCase();
        return cl && cl === pn;
      });

      const atPort = filterCatchesByIntelRange(atPortAll);
      const total = atPort.length;

      if (total === 0){
        el.innerHTML = `
          <div style="font-weight:900; color:var(--white); margin-bottom:6px;">${escapeHtml(portName)}</div>
          <div class="muted">No catches found for this port in the selected range.</div>
          <div class="muted" style="margin-top:8px;">Based on 0 catches.</div>
        `;
        return;
      }

      const tideBuckets = {};
      const phases = {};
      const moon = {};
      const hours = {};

      // Track how many catches actually contributed to each section
      let tideN = 0;
      let phaseN = 0;
      let moonN = 0;
      let hourN = 0;

      for (const c of atPort){
        // Hour-of-day from timestamp
        const ts = catchTimestampMs(c);
        if (ts){
          const h = new Date(ts).getHours();
          const key = `${String(h).padStart(2,'0')}:00`;
          hours[key] = (hours[key]||0)+1;
          hourN++;
        }

        // Tide context (prefer stored; otherwise try derive; otherwise fall back to saved tide label)
        const tc = c.tideCtx || c.tideContext || tideContextFor(ts || Date.now(), c.portId || portId);
        let tideAdded = false;
        let phaseAdded = false;

        if (tc){
          if (tc.bucket){ tideBuckets[tc.bucket] = (tideBuckets[tc.bucket]||0)+1; tideAdded = true; }
          if (tc.phase){ phases[tc.phase] = (phases[tc.phase]||0)+1; phaseAdded = true; }
        } else {
          const tlabel = (c.tide || "").toString().toLowerCase();
          // Older records may only store a simple label like "7.6m High". Use a coarse bucket so intel isn't blank.
          if (tlabel.includes("high")){ tideBuckets["HW (near)"] = (tideBuckets["HW (near)"]||0)+1; tideAdded = true; }
          if (tlabel.includes("low")){ tideBuckets["LW (near)"] = (tideBuckets["LW (near)"]||0)+1; tideAdded = true; }
          if (tlabel.includes("rising")){ phases["Rising"] = (phases["Rising"]||0)+1; phaseAdded = true; }
          if (tlabel.includes("falling")){ phases["Falling"] = (phases["Falling"]||0)+1; phaseAdded = true; }
        }

        if (tideAdded) tideN++;
        if (phaseAdded) phaseN++;

        // Moon phase (stored, or derive)
        const mp = c.moon || (ts ? moonPhaseInfo(ts) : null);
        if (mp && mp.name){
          moon[mp.name] = (moon[mp.name]||0)+1;
          moonN++;
        }
      }

      const bestTide = topN(tideBuckets, 1)[0];
      const bestPhase = topN(phases, 1)[0];
      const bestMoon = topN(moon, 1)[0];
      const bestHour = topN(hours, 1)[0];

      function fmtStat(pair, label, nUsed){
        if (!pair || !pair[0]) return `<div class="muted">${escapeHtml(label)}: Not enough data yet.</div>`;
        const denom = Math.max(1, nUsed || total);
        const pct = Math.round((pair[1]/denom)*100);
        return `<div><b>${escapeHtml(label)}:</b> <span class="muted">${escapeHtml(pair[0])}</span> <span class="muted">(${pct}%)</span> <span class="muted">‚Ä¢ based on ${nUsed || 0}</span></div>`;
      }

      // If overall sample is small, still show whatever we can, but label the sample clearly.
      const overallNote = total < 3
        ? `<div class="muted" style="margin-top:8px;">Low sample size ‚Äî patterns may be noisy.</div>`
        : "";

      el.innerHTML = `
        <div style="font-weight:900; color:var(--white); margin-bottom:6px;">${escapeHtml(portName)}</div>
        <div style="display:grid; gap:6px;">
          ${fmtStat(bestTide, "Best tide window", tideN)}
          ${fmtStat(bestPhase, "Rising vs falling", phaseN)}
          ${fmtStat(bestHour, "Best time", hourN)}
          ${fmtStat(bestMoon, "Best moon", moonN)}
        </div>
        ${overallNote}
        <div class="muted" style="margin-top:8px;">Based on ${total} catch${total===1?"":"es"} in this range.</div>
      `;
    }


    async function saveCatch() {
      const s = document.getElementById('sp').value.trim();
      if (!s) return notify("Enter Species");

      const now = new Date();
      const dStr = todayStr();
      const tStr = now.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });

      const wt = Number(document.getElementById('wt').value || 0);
      const len = Number(document.getElementById('len').value || 0);
      const notes = document.getElementById('notes').value || "";

      const file = document.getElementById('photo').files?.[0];
      const photo = file ? await fileToCompressedDataUrl(file, 900, 0.72) : "";

      const nowMs = Date.now();
      const activeSession = SessionEngine.ensureActive(getSessionMetaFromEnv());
      renderSessionBar();

            const moon = moonPhaseInfo(nowMs);
      const tideCtx = tideContextFor(nowMs, envData.id || envData.portId || null);

      await addDoc(collection(db, "catches"), {
        userId: auth.currentUser.uid,
        sp: s.toUpperCase(),
        wt,
        len,
        notes,
        photo,

        dt: dStr,
        time: tStr,
        loc: envData.port,
        portId: envData.id || envData.portId || "",
        moon,
        tideCtx,

        press: envData.press || "",
        baro: envData.press || "",
        temp: envData.temp || "",
        weather: envData.weather || "",
        wind: envData.wind || "",
        gust: envData.gust || "",
        tide: envData.tide || "",
        flow: envData.flow || "",

        sessionId: activeSession.id,
        caughtAt: nowMs,

        createdAt: Date.now(),
        timestamp: Date.now()
      });

      updateSessionBadge();
      notify("RECORD SAVED");
      renderMyIntel();
      document.getElementById('sp').value = "";
      document.getElementById('wt').value = "";
      document.getElementById('len').value = "";
      document.getElementById('notes').value = "";
      document.getElementById('photo').value = "";
    }

    // ===== Wire UI =====
    function wireUI() {
      document.getElementById('loginBtn').onclick = async () => {
        try {
          await signInWithEmailAndPassword(
            auth,
            document.getElementById('loginEmail').value,
            document.getElementById('loginPass').value
          );
        } catch (e) {
          console.error(e);
          notify("Login Error");
        }
      };

      document.getElementById('logoutBtn').onclick = () => signOut(auth);


      // Intel range selector
      applySavedIntelRange();
      renderIntelRangeMeta();
      const intelSel = document.getElementById('intelRange');
      if (intelSel) {
        intelSel.onchange = () => {
          localStorage.setItem(INTEL_RANGE_KEY, intelSel.value);
          renderMyIntel();
        };
      }

      document.getElementById('portList').onchange = (e) => {
        const val = e.target.value;
        if (val) handlePort(val);
      };

      // If the user clicks an already-highlighted option, 'change' may not fire.
      // Apply selection on click as well.
      document.getElementById('portList').onclick = (e) => {
        const val = e.target.value;
        if (val) handlePort(val);
      };

      document.getElementById('gpsSyncBtn').onclick = () => {
        navigator.geolocation.getCurrentPosition(
          pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            const acc = pos.coords.accuracy; // meters

            const ACC_LIMIT = 5000; // 5km guardrail
            if (!acc || acc > ACC_LIMIT) {
              notify(`‚ö†Ô∏è GPS accuracy too low (¬±${Math.round(acc || 0)}m). Not selecting a port.`);
              console.warn("Low-accuracy GPS:", { lat, lon, acc });
              return;
            }

            const n = nearestPort(lat, lon);
            if (!n) return notify("Ports not loaded yet");

            resetPortSearchUI();
            document.getElementById('portList').value = String(n.id);
            handlePort(n.id);

            const km = (n._distMeters / 1000).toFixed(1);
            notify(`üìç GPS: ${n.name.toUpperCase()} (${km}km away, ¬±${Math.round(acc)}m)`);
          },
          err => {
            console.warn("Geolocation error:", err);
            notify("GPS Denied");
          },
          { enableHighAccuracy: true, timeout: 20000, maximumAge: 60000 }
        );
      };

      document.getElementById('addFavBtn').onclick = async () => {
        // If the user typed in the search box but didn‚Äôt explicitly confirm a selection,
        // the dropdown may already have the right value while envData.id is still empty.
        if (!envData.id) {
          const v = document.getElementById('portList')?.value;
          if (v) {
            try { await handlePort(String(v)); } catch {}
          }
        }
        if (!envData.id) return;

        const exists = favs.some(f => String(f.id) === String(envData.id));
        if (exists) {
          notify(`"${envData.port}" is already a favourite`);
          setFavButtonState();
          return;
        }

        favs.push({ id: String(envData.id), name: envData.port });
        localStorage.setItem('aos_favs', JSON.stringify(favs));
        updateFavsUI();
        setFavButtonState();
        notify(`Added "${envData.port}" to favourites`);
      };

      document.getElementById('saveBtn').onclick = saveCatch;

      document.getElementById('totalsBtn').onclick = () => {
        const box = document.getElementById('totalsBox');
        if (box.style.display === 'block') {
          box.style.display = 'none';
        } else {
          document.getElementById('totalsSummary').innerHTML = buildSessionSummaryHtml();
          box.style.display = 'block';
        }
      };


      document.getElementById('sessionStartBtn').onclick = () => {
        const s = SessionEngine.start(getSessionMetaFromEnv());
        updateSessionBadge();
        renderSessionBar();
        notify("Session started");
      };

      document.getElementById('sessionEndBtn').onclick = () => {
        const s = SessionEngine.getActive();
        if (!s) return notify("No active session");
        SessionEngine.end(s.id);
        updateSessionBadge();
        renderSessionBar();
        notify("Session ended");
      };

      document.getElementById('helpBtn').onclick = () => showHelp();
document.getElementById('aboutBtn').onclick = () => {
        const year = new Date().getFullYear();
        openModal("About AnglerOS", `
          <div style="font-size:0.9rem; line-height:1.6;">
            <div><b>AnglerOS</b> v13.10.7</div>
            <div class="muted">¬© ${year} AnglerOS. All rights reserved.</div>
            <div class="muted" style="margin-top:10px;">
              Prototype build for testing (Firestore-only photo storage with compression).
            </div>
          </div>
        `);
      };
    }

    // ===== App init =====
    async function initApp(uid) {
      currentUid = uid;

      initMapOnce();
      await loadPorts();
      updateFavsUI();
      setFavButtonState();
      renderSessionBar();
      showQuickStartOnce();

      const qy = query(
        collection(db, "catches"),
        where("userId", "==", uid),
        orderBy("timestamp", "desc")
      );

      onSnapshot(
        qy,
        (snap) => {
          catches = snap.docs.map(d => ({ id: d.id, ...d.data() }));
          updateSessionBadge();
          renderSessionBar();

          const box = document.getElementById('totalsBox');
          if (box.style.display === 'block') {
            document.getElementById('totalsSummary').innerHTML = buildSessionSummaryHtml();
          }

          // Default history view: today (unless user manually selected another date)
          if (!userSelectedDate) {
            selectedDate = todayStr();
          }

          renderCalendar();
          renderDiary();
          renderMyIntel();
},
        (err) => {
          console.error("Firestore listener error:", err);
          if (err?.code === "permission-denied") notify("Firestore blocked by rules (permission denied).");
          else notify("Firestore error: " + (err?.code || "unknown"));
        }
      );
    }

    document.addEventListener('DOMContentLoaded', () => {
      wireUI();

      // Tick session duration label
      setInterval(() => { try { renderSessionBar(); } catch {} }, 30000);

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          document.getElementById('authScreen').style.display = 'none';
          document.getElementById('mainApp').style.display = 'block';
          if (!currentUid) await initApp(user.uid);
        } else {
          currentUid = null;
          document.getElementById('authScreen').style.display = 'flex';
          document.getElementById('mainApp').style.display = 'none';
        }
      });
    });
  </script>

<script>
/* ===== SOLUNAR / BITE WINDOW ===== */
function getSolunarWindows(date, lat, lon) {
  // Simplified solunar approximation:
  // Major: moon overhead/underfoot
  // Minor: moonrise/moonset
  // We approximate using lunar age already calculated in app

  if (!lat || !lon || isNaN(lat) || isNaN(lon)) return null;

  const dayMs = 86400000;
  const lunarDay = 24.84 * 60 * 60 * 1000;

  const base = new Date(date);
  base.setHours(0,0,0,0);

  // Use stored moon age if available
  const moonAge = window.currentMoonAgeDays ?? 0;
  const ageFraction = moonAge / 29.53;

  const majorOffset = ageFraction * lunarDay;
  const minorOffset = (ageFraction * lunarDay + lunarDay/2) % lunarDay;

  const majorStart = new Date(base.getTime() + majorOffset - 60*60*1000);
  const majorEnd   = new Date(base.getTime() + majorOffset + 60*60*1000);

  const minorStart = new Date(base.getTime() + minorOffset - 45*60*1000);
  const minorEnd   = new Date(base.getTime() + minorOffset + 45*60*1000);

  return { majorStart, majorEnd, minorStart, minorEnd };
}

function updateBiteCard() {
  const primary = document.getElementById("hBite");
  const secondary = document.getElementById("hBiteD");

  if (!primary || !secondary) return;

  if (!window.currentLat || !window.currentLon) {
    primary.textContent = "Location needed";
    secondary.textContent = "Enable GPS or select favourite";
    return;
  }

  const now = new Date();
  const sol = getSolunarWindows(now, window.currentLat, window.currentLon);
  if (!sol) {
    primary.textContent = "Unavailable";
    secondary.textContent = "";
    return;
  }

  function fmt(t){ return t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }

  let nextLabel = "";
  let nextStart, nextEnd;

  if (now < sol.majorEnd) {
    nextLabel = "Major";
    nextStart = sol.majorStart;
    nextEnd = sol.majorEnd;
  } else {
    nextLabel = "Minor";
    nextStart = sol.minorStart;
    nextEnd = sol.minorEnd;
  }

  const mins = Math.max(0, Math.round((nextStart - now)/60000));

  if (now >= nextStart && now <= nextEnd) {
    primary.textContent = nextLabel + " window active";
    secondary.textContent = fmt(nextStart) + "‚Äì" + fmt(nextEnd);
  } else {
    primary.textContent = nextLabel + " in " + mins + " min";
    secondary.textContent = fmt(nextStart) + "‚Äì" + fmt(nextEnd);
  }
}

// hook into existing refresh cycle
setInterval(updateBiteCard, 60000);
document.addEventListener("DOMContentLoaded", updateBiteCard);
</script>

</body>
</html>
