<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>BiteWise</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --navy:#050b14; --card:#121c2b; --sea:#34e89e; --gold:#f4af1b; --white:#f1f2f6;
      --text:#cbd5e0; --red:#ff4757; --border:#1e293b; --muted:#64748b;
    }

    *{ box-sizing:border-box; }

    body{
      font-family:\'Segoe UI\',sans-serif;background:var(--navy);
      margin:0;padding:calc(10px + env(safe-area-inset-top)) calc(10px + env(safe-area-inset-right)) calc(10px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));color:var(--text);-webkit-tap-highlight-color:transparent;
    }

    .app-container{max-width:500px;margin:0 auto;padding-bottom:50px;display:none;}

    #authScreen{
      position:fixed;inset:0;background:var(--navy);z-index:9999;
      display:flex;justify-content:center;align-items:center;
    }
    .auth-card{
      background:var(--card);border:2px solid var(--gold);
      padding:30px;border-radius:20px;width:85%;max-width:340px;text-align:center;
    }

    .drawer{display:none;background:var(--card);border:1px solid var(--gold);border-radius:15px;padding:15px;margin-bottom:15px;}
    #myIntelToggleBtn{position:static; z-index:3;}
    @media (min-width: 900px){
      #myIntelToggleBtn{position:sticky; top:calc(10px + env(safe-area-inset-top));}
    }
    #myIntelDrawer .intel-card{margin:0; border:none; background:transparent; padding:0;}

    .card{background:var(--card);border:1px solid var(--border);padding:15px;border-radius:20px;margin-bottom:15px;}
    .intel-card{border:1px solid var(--gold);border-radius:20px;padding:15px;margin-bottom:15px;background:var(--card);}

    .intel-header{color:var(--gold);font-weight:900;margin-bottom:10px;display:flex;align-items:center;gap:8px;font-size:0.9rem;}
    .intel-list{list-style:none;padding:0;margin:0;font-size:0.8rem;color:var(--white);line-height:1.8;margin-bottom:0;}
    .intel-list li::before{content:"‚Ä¢ ";color:var(--gold);font-weight:bold;}

    /* Header with truly centered logo */
    .app-header{
      position:relative;
      display:flex;
      align-items:center;
      margin-bottom:12px;
      min-height:42px;
      gap:8px;
    }
    .header-left,.header-right{display:flex;gap:8px;z-index:1;}
    .header-right{margin-left:auto;}
    .header-center{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      pointer-events:none;
    }
    .app-logo{
      font-size:1.2rem;
      font-weight:900;
      color:var(--white);
      letter-spacing:.5px;
      white-space:nowrap;
    }

    .hud-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;}
    .hud-item{background:var(--card);padding:12px;border-radius:12px;border:1px solid var(--border);text-align:center;}
    .label{font-size:0.65rem;color:var(--muted);text-transform:uppercase;font-weight:900;display:block;margin-bottom:4px;}
    .val{font-size:1.05rem;font-weight:900;color:var(--white);}
    .sub-val{font-size:0.72rem;font-weight:900;display:block;color:var(--sea);margin-top:2px;}
    .sub-val.red{color:var(--red);}
    /* Bite card emphasis */
    @keyframes aosPulse { 0%{transform:scale(1);} 50%{transform:scale(1.01);} 100%{transform:scale(1);} }
    .hud-item.is-active{border-color:rgba(255,255,255,0.25); box-shadow:0 0 0 2px rgba(255,255,255,0.06), 0 10px 28px rgba(0,0,0,0.35);}
    .hud-item.is-hot{animation:aosPulse 1.6s ease-in-out infinite;}


    .btn-main{
      width:100%;background:var(--sea);color:var(--navy);border:none;
      padding:14px;border-radius:12px;font-weight:900;cursor:pointer;margin-bottom:10px;
      font-size:0.9rem;text-transform:uppercase;
    }
    .btn-sub{
      background:var(--card);border:1px solid var(--border);color:var(--gold);
      padding:10px;border-radius:10px;font-size:0.75rem;font-weight:900;cursor:pointer;
    }

    .btn-fav{
      width:44px;min-width:44px;background:var(--card);border:1px solid var(--border);
      color:var(--gold);border-radius:10px;font-size:1rem;font-weight:900;cursor:pointer;line-height:1;
    }
    .btn-fav.active{background:var(--gold);color:var(--navy);border-color:var(--gold);}
    .btn-fav.disabled{background:#2a3344;color:#7b879d;border-color:#2a3344;cursor:not-allowed;}

    input,select,textarea{
      width:100%;padding:12px;margin-bottom:8px;border:1px solid var(--border);
      border-radius:10px;background:var(--navy);color:var(--white);
    }
    #map{height:180px;border-radius:15px;border:1px solid var(--border);margin-bottom:15px;cursor:crosshair;}

    #toast{
      visibility:hidden;min-width:250px;background:var(--gold);color:var(--navy);
      text-align:center;border-radius:10px;padding:15px;position:fixed;z-index:100000;
      left:50%;bottom:calc(20px + env(safe-area-inset-bottom));transform:translateX(-50%);font-weight:900;
    }
    #toast.show{visibility:visible;}

    .catch-meta{font-size:0.65rem;color:var(--muted);margin-top:6px;display:grid;grid-template-columns:1fr 1fr;gap:5px;}
    .thumb{width:100%;border-radius:12px;border:1px solid var(--border);margin-top:10px;cursor:pointer;}
    .pb{border:1px solid var(--gold)!important;box-shadow:0 0 0 1px rgba(244,175,27,0.15);}
    .pb-badge{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:999px;background:rgba(244,175,27,0.15);color:var(--gold);font-size:0.65rem;font-weight:900;}

    .cal-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:8px;text-align:center;}
    .cal-day{aspect-ratio:1;display:flex;align-items:center;justify-content:center;font-size:0.8rem;border-radius:10px;cursor:pointer;position:relative;color:var(--text);background:var(--navy);}
    .cal-day.has-catch::after{content:'';width:6px;height:6px;background:var(--sea);border-radius:50%;position:absolute;bottom:4px;}
    .cal-day.selected{background:var(--sea);color:var(--navy);font-weight:900;}

    .tide-table{width:100%;border-collapse:collapse;font-size:0.78rem;}
    .tide-table th,.tide-table td{padding:8px 6px;border-bottom:1px solid var(--border);vertical-align:top;}
    .tide-table th{color:var(--gold);text-align:left;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.04em;}
    .day-row{color:var(--white);font-weight:900;padding-top:10px;}

    .inline-actions{display:flex;flex-direction:column;gap:6px;}
    .edit-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;}

    /* Modal */
    #modalOverlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.65);z-index:200000;justify-content:center;align-items:center;padding:calc(12px + env(safe-area-inset-top)) calc(12px + env(safe-area-inset-right)) calc(12px + env(safe-area-inset-bottom)) calc(12px + env(safe-area-inset-left));}
    #modal{width:100%;max-width:480px;background:var(--card);border:1px solid var(--gold);border-radius:16px;padding:14px;}
    #modalTop{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px;}
    #modalTitle{margin:0;color:var(--white);font-size:1rem;font-weight:900;}
    #modalClose{background:none;border:none;color:var(--gold);font-weight:900;font-size:1.2rem;cursor:pointer;}

    .muted{opacity:0.7}
  
    /* Photo picker: use camera icon instead of "Choose file" */
    .photo-input{display:none;}
    .photo-actions{display:flex; gap:10px; align-items:center;}
    .photo-btn{
      display:flex;align-items:center;justify-content:center;
      height:44px; width:52px;
      border:1px solid var(--border);
      border-radius:10px;
      background:var(--navy);
      color:var(--gold);
      font-size:1.25rem;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      flex: 0 0 auto;
    }
    .photo-btn:active{transform:scale(.99);}

  
    /* Session bar */
    .session-bar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      background:rgba(18,28,43,.95);
      border:1px solid var(--gold);
      border-radius:14px;
      padding:10px 12px;
      margin-bottom:12px;
    }
    .session-left{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .session-title{font-weight:900; color:var(--white); font-size:0.85rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .session-sub{font-weight:900; color:var(--muted); font-size:0.7rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .session-actions{display:flex; gap:8px; flex:0 0 auto;}
    .btn-pill{
      border:1px solid var(--border);
      background:var(--navy);
      color:var(--gold);
      padding:9px 10px;
      border-radius:999px;
      font-size:0.72rem;
      font-weight:900;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn-pill.red{border-color:var(--red); color:var(--red);}
    
  
    /* Header spacing fix */
    .header{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .header-left{flex:0 0 auto;}
    .header-center{flex:1 1 auto; text-align:center; padding:0 84px;} /* room for right buttons */
    .header-right{flex:0 0 auto; display:flex; gap:8px; align-items:center;}
    @media (max-width: 420px){
      .header-center{padding:0 72px;}
      #helpBtn{padding:10px 10px; min-width:auto;}
      #totalsBtn{padding:10px 10px;}
    }
    
  
    /* Modal scroll fix */
    .modal{
      max-height: 90vh;
      overflow: hidden;
    }
    .modal-content{
      max-height: 90vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .modal-header{
      position: sticky;
      top: 0;
      background: var(--navy);
      z-index: 2;
    }
    .modal-close{
      background:none;
      border:none;
      color:var(--gold);
      font-size:1.2rem;
      font-weight:900;
      cursor:pointer;
    }

    /* Modal fit + scroll (IDs) */
    #modal{
      max-height: 90vh;
      overflow: hidden;
    }
    #modalTop{
      position: sticky;
      top: 0;
      background: var(--navy);
      z-index: 2;
    }
    #modalBody{
      max-height: 78vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 4px;
    }
    
  </style>
</head>

<body>
  <div id="toast">Message</div>

  
  <div id="authScreen">
    <div class="auth-card">
      <h2 style="color:var(--white); margin-top:0;">BITE<span style="color:var(--sea)">WISE</span></h2>
      <input type="email" id="loginEmail" placeholder="Email Address" />
      <input type="password" id="loginPass" placeholder="Password" />
      <button class="btn-main" id="loginBtn">LOG IN</button>

      <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="btn-sub" id="createAccountBtn" style="flex:1;">CREATE ACCOUNT</button>
        <button class="btn-sub" id="forgotPassBtn" style="flex:1;">FORGOT?</button>
      </div>

      <div class="muted" style="margin-top:10px; font-size:0.85rem; line-height:1.25;">
        Tip: Use the same email/password to log in on this device later.
      </div>
    </div>
  </div>


  <div class="app-container" id="mainApp">
    <!-- Header -->
    <div class="app-header">
      <div class="header-left">
        <button class="btn-sub" style="border-color:var(--red); color:var(--red);" id="logoutBtn">LOGOUT</button>
        <button class="btn-sub" id="aboutBtn">‚ÑπÔ∏è ABOUT</button>
      </div>

      <div class="header-center">
        <span class="app-logo">BITE<span style="color:var(--sea)">WISE</span></span>
      </div>

      <div class="header-right">
        <button class="btn-sub" id="helpBtn" title="Help" style="white-space:nowrap;">‚ùì</button>
        <button class="btn-sub" id="totalsBtn" title="Session summary" style="white-space:nowrap;">üß≠ SESSION: 0</button>
      </div>
    </div>


    <!-- Session bar -->
    <div id="sessionBar" class="session-bar" aria-label="Session controls">
      <div class="session-left">
        <div id="sessionTitle" class="session-title">No active session</div>
        <div id="sessionSub" class="session-sub">Tap START to begin (auto-starts when you save your first catch).</div>
      </div>
      <div class="session-actions">
        <button class="btn-pill" id="sessionStartBtn">‚ñ∂Ô∏è START</button>
        <button class="btn-pill red" id="sessionEndBtn">‚èπ END</button>
      </div>
    </div>

    <!-- Session summary drawer -->
    <div id="totalsBox" class="drawer">
      <div class="intel-header">üß≠ SESSION SUMMARY</div>
      <div id="totalsSummary" class="muted">No active session.</div>

    </div>

    <!-- Favourites -->
    <button class="btn-sub" style="width:100%; margin-bottom:10px;" onclick="toggle('favBox')">‚≠ê FAVOURITES</button>
    <div id="favBox" class="drawer"><div id="favList"></div></div>

    <!-- My intel -->
    
    <!-- My BiteWise Intel toggle -->
    <button class="btn-main" id="myIntelToggleBtn" style="width:100%; margin-bottom:12px;">üß† My BiteWise Intel</button>

    <div class="drawer" id="myIntelDrawer" style="display:none;">
<div class="intel-card">
      <div class="intel-header" style="justify-content:space-between; width:100%;">
        <span>üß† MY INTEL</span>
        <select id="intelRange" style="width:auto; padding:8px 10px; margin:0; font-size:0.75rem; font-weight:900;">
          <option value="7">Last 7 days</option>
          <option value="30" selected>Last 30 days</option>
          <option value="90">Last 90 days</option>
          <option value="all">All-time</option>
        </select>
      </div>
      <div id="intelRangeMeta" class="muted" style="font-size:0.72rem; margin-top:-6px; margin-bottom:8px;"></div>
      <div id="myIntelBody" class="muted" style="line-height:1.55;">
        Select a port to see patterns from your catches.
      </div>
    
    </div>

        </div>

    <div id="map"></div>


    <button class="btn-main" id="gpsSyncBtn">üìç Find Nearest Port</button>

    <!-- Catch Explorer -->
    <div class="card" id="explorerCard">
      <div class="intel-header" style="justify-content:space-between; width:100%;">
        <span>üîé CATCH EXPLORER</span>
        <button class="btn-sub" id="explorerToggleBtn" style="padding:8px 10px;">Show</button>
      </div>
      <div id="explorerBody" style="display:none; margin-top:10px;">
        <div class="grid2" style="gap:8px;">
          <select id="expPort" style="margin:0;">
            <option value="all">All ports</option>
            <option value="selected">Selected port</option>
          </select>
          <select id="expRange" style="margin:0;">
            <option value="30">Last 30 days</option>
            <option value="90">Last 90 days</option>
            <option value="365">Last 365 days</option>
            <option value="all" selected>All-time</option>
          </select>

          <select id="expTidePhase" style="margin:0;">
            <option value="any" selected>Any tide phase</option>
            <option value="rising">Rising</option>
            <option value="falling">Falling</option>
          </select>
          <select id="expTideStage" style="margin:0;">
            <option value="any" selected>Any tide stage</option>
            <option value="early">Early</option>
            <option value="mid">Mid</option>
            <option value="late">Late</option>
          </select>

          <select id="expWindDir" style="margin:0;">
            <option value="any" selected>Any wind dir</option>
            <option value="N">N</option><option value="NNE">NNE</option><option value="NE">NE</option><option value="ENE">ENE</option>
            <option value="E">E</option><option value="ESE">ESE</option><option value="SE">SE</option><option value="SSE">SSE</option>
            <option value="S">S</option><option value="SSW">SSW</option><option value="SW">SW</option><option value="WSW">WSW</option>
            <option value="W">W</option><option value="WNW">WNW</option><option value="NW">NW</option><option value="NNW">NNW</option>
          </select>
          <div style="display:flex; gap:8px;">
            <input id="expWindMin" type="number" placeholder="Wind min" style="margin:0;" />
            <input id="expWindMax" type="number" placeholder="Wind max" style="margin:0;" />
          </div>

          <select id="expTime" style="margin:0;">
            <option value="any" selected>Any time</option>
            <option value="dawn">Dawn</option>
            <option value="day">Day</option>
            <option value="dusk">Dusk</option>
            <option value="night">Night</option>
          </select>
          <button class="btn-main" id="expApplyBtn" style="margin:0;">Apply</button>
        </div>

        <div id="expSummary" class="muted" style="margin-top:10px;"></div>

        <div class="card" style="padding:10px; margin:10px 0 0;">
          <div class="intel-header" style="margin:0 0 6px;">‚≠ê Best conditions</div>
          <div class="muted" style="font-size:0.85rem; margin-bottom:6px;">
            Based on your catch history in the selected range (and port scope).
          </div>
          <div id="expBestConditions" class="muted"></div>
        </div>


        <div class="grid2" style="gap:10px; margin-top:10px;">
          <div class="card" style="padding:10px; margin:0;">
            <div class="intel-header" style="margin:0 0 6px;">Top ports</div>
            <div id="expTopPorts" class="muted"></div>
          </div>
          <div class="card" style="padding:10px; margin:0;">
            <div class="intel-header" style="margin:0 0 6px;">Top times</div>
            <div id="expTopTimes" class="muted"></div>
          </div>
          <div class="card" style="padding:10px; margin:0;">
            <div class="intel-header" style="margin:0 0 6px;">Top species</div>
            <div id="expTopSpecies" class="muted"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="padding:10px;">
      <div style="display:flex; gap:5px;">
        <input type="text" id="pSearch" placeholder="Search ports..." style="margin:0;" />
        <button class="btn-fav" id="addFavBtn" title="">‚≠ê</button>
      </div>
      <select id="portList" style="margin-top:8px;"></select>
    </div>

    <div class="hud-grid">
      <div class="hud-item">
        <span class="label">Tide</span>
        <div id="hTide" class="val">--</div>
        <span id="hTideD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Flow</span>
        <div id="hFlow" class="val">--</div>
        <span id="hFlowD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Pressure</span>
        <div id="hPress" class="val">--</div>
        <span id="hPressD" class="sub-val">--</span>
      </div>

      <div class="hud-item">
        <span class="label">Moon</span>
        <div id="hMoon" class="val">--</div>
        <span id="hMoonD" class="sub-val">--</span>
      </div>

      <div class="hud-item" id="hudBite">
        <span class="label">Bite</span>
        <div id="hBite" class="val">--</div>
        <span id="hBiteD" class="sub-val">--</span>
      </div>


      <div class="hud-item">
        <span class="label">Weather</span>
        <div id="hCond" class="val">--</div>
        <span id="hWind" class="sub-val">--</span>
        <span id="hGust" class="sub-val red" style="display:none;">--</span>
      </div>
    </div>

    <button class="btn-sub" style="width:100%; margin-bottom:15px;" onclick="toggle('tideBox')">üåô 7-DAY TIDES</button>
    <div id="tideBox" class="drawer">
      <div class="intel-header">üåô 7-DAY TIDE OUTLOOK</div>
<div id="tideOutlook" class="muted">Select a port to load tides.</div>
    </div>

    <div class="card">
      <div class="edit-grid">
        <input type="text" id="sp" placeholder="Species" style="margin:0;">
        <input type="number" id="wt" placeholder="Weight (lb)" style="margin:0;">
      </div>
      <div class="edit-grid">
        <input type="number" id="len" placeholder="Length (cm)" style="margin:0;">
        <div class="photo-actions">
  <input type="file" id="photo" class="photo-input" accept="image/*">
  <label for="photo" class="photo-btn" title="Add photo" aria-label="Add photo">üì∑</label>
</div>
      </div>
      <textarea id="notes" placeholder="Notes..." style="margin-top:8px; height:70px;"></textarea>
      <button class="btn-main" id="saveBtn">üíæ SAVE RECORD</button>
    </div>

    <div class="card">
      <div class="intel-header">HISTORY CALENDAR</div>
      <div class="cal-grid" id="calGrid"></div>
    </div>

    <div id="diary"></div>
  </div>

  <!-- Modal overlay (About / image preview) -->
  <div id="modalOverlay">
    <div id="modal">
      <div id="modalTop">
        <h3 id="modalTitle">Modal</h3>
        <button id="modalClose" aria-label="Close">‚úï</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getAuth,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import {
      initializeFirestore,
      persistentLocalCache,
      persistentMultipleTabManager,
      collection,
      addDoc,
      onSnapshot,
      query,
      where,
      orderBy,
      limit,
      getDocs,
      getDoc,
      setDoc,
      updateDoc,
      deleteDoc,
      doc,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getStorage,
      ref as sRef,
      uploadBytes,
      getDownloadURL,
      deleteObject
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDICIj5QIcCLhrq_tlC0QsLKwpB4T7CkoU",
      authDomain: "angleros.firebaseapp.com",
      projectId: "angleros",
      storageBucket: "angleros.firebasestorage.app",
      messagingSenderId: "471426311094",
      appId: "1:471426311094:web:25c0b54a6e1fa7a42e5717"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = initializeFirestore(app, {
      localCache: persistentLocalCache({
        tabManager: persistentMultipleTabManager()
      })
    });
    // Offline persistence enabled via localCache above
    const storage = getStorage(app);

    const AD_KEY = '05819e75195f4d5f8e73742dd5d57c39';
    const PROXY = "https://corsproxy.io/?";

    let catches = [];
    let unsubCatches = null;
    let allPorts = [];
    let favs = JSON.parse(localStorage.getItem('aos_favs')) || [];
    let map, marker;
    let selectedDate = "";
    let userSelectedDate = false;

    

    let currentUid = null;

    let envData = { id:"", port:"Unknown", press:"--", temp:"--", wind:"--", gust:"", weather:"--", tide:"--", flow:"--", tideDir:"--", tideETA:"--" };

    // Tide cache for monthly view
    const tideCache = { portId: null, events: [], fetchedAt: 0 };


    function notify(m) {
      const t = document.getElementById("toast");
      t.innerText = m;
      t.className = "show";
      setTimeout(() => (t.className = ""), 3200);
    }
    window.notify = notify;

    function escapeHtml(str) {
      return (str ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function toggle(id) {
      const e = document.getElementById(id);
      e.style.display = e.style.display === 'block' ? 'none' : 'block';
    }
    window.toggle = toggle;

    // ===== Modal =====
    const modalOverlay = document.getElementById('modalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    document.getElementById('modalClose').onclick = () => closeModal();
    modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) closeModal(); });

    function openModal(title, html) {
      modalTitle.innerText = title;
      modalBody.innerHTML = html;
      modalOverlay.style.display = "flex";
      document.getElementById('modalClose')?.addEventListener('click', closeModal);

    }
    function closeModal() {
      modalOverlay.style.display = "none";
      modalBody.innerHTML = "";
    }
    window.openModal = openModal;

    // ===== Date helpers =====
    function dStr(ms){
      const now = new Date(ms);
      return `${String(now.getDate()).padStart(2,'0')}/${String(now.getMonth()+1).padStart(2,'0')}/${now.getFullYear()}`;
    }
    function todayStr(){
      return dStr(Date.now());
    }

    function fmtDuration(ms) {
      const s = Math.max(0, Math.floor(ms/1000));
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      if (h <= 0) return `${m}m`;
      return `${h}h ${m}m`;
    }

    // ===== Weather helpers =====
    function degToDir(deg) {
      if (typeof deg !== "number") return "--";
      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
      return dirs[Math.round(deg/22.5) % 16];
    }
    function weatherCodeToText(code) {
      const map = {
        0:"Clear", 1:"Mainly clear", 2:"Partly cloudy", 3:"Overcast",
        45:"Fog", 48:"Rime fog",
        51:"Light drizzle", 53:"Drizzle", 55:"Heavy drizzle",
        56:"Freezing drizzle", 57:"Heavy freezing drizzle",
        61:"Light rain", 63:"Rain", 65:"Heavy rain",
        66:"Freezing rain", 67:"Heavy freezing rain",
        71:"Light snow", 73:"Snow", 75:"Heavy snow",
        77:"Snow grains",
        80:"Rain showers", 81:"Heavy showers", 82:"Violent showers",
        85:"Snow showers", 86:"Heavy snow showers",
        95:"Thunderstorm", 96:"Thunderstorm + hail", 99:"Thunderstorm + heavy hail"
      };
      return map[code] ?? "‚Äî";
    }

    // ‚úÖ Proper Earth distance (meters)
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (v) => (v * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function nearestPort(lat, lon) {
      if (!allPorts.length) return null;
      let best = null;
      let bestDist = Infinity;
      for (const p of allPorts) {
        const d = haversineMeters(lat, lon, p.lat, p.lon);
        if (d < bestDist) { bestDist = d; best = p; }
      }
      if (best) best._distMeters = bestDist;
      return best;
    }

    // ===== Ports loading + search =====
    async function loadPorts() {
      const s = document.getElementById('portList');
      s.innerHTML = "";

      const placeholder = document.createElement('option');
      placeholder.value = "";
      placeholder.textContent = "Please select a port...";
      placeholder.disabled = true;
      placeholder.selected = true;
      s.appendChild(placeholder);

      const r = await fetch(PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations?subscription-key=${AD_KEY}`));
      const d = await r.json();

      allPorts = (d?.features || [])
        .map(f => ({
          id: String(f.properties.Id),
          name: f.properties.Name,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0]
        }))
        .sort((a,b) => a.name.localeCompare(b.name));

      allPorts.forEach(p => {
        const o = document.createElement('option');
        o.value = p.id;
        o.textContent = p.name;
        s.appendChild(o);
      });

      const search = document.getElementById('pSearch');
      search.oninput = () => {
        const q = search.value.trim().toLowerCase();
        let visible = 0;
        let firstMatch = null;
        let lastMatch = null;

        [...s.options].forEach((opt, idx) => {
          if (idx === 0) return;
          const ok = !q || opt.textContent.toLowerCase().includes(q);
          opt.hidden = q && !ok;
          if (ok) {
            visible++;
            if (!firstMatch) firstMatch = opt;
            lastMatch = opt;
          }
        });

        // Show "suggestions" by expanding the select into a short list while typing
        if (q) {
          s.size = Math.min(7, Math.max(2, visible + 1)); // +1 for the placeholder row
        } else {
          s.size = 0;
        }

        // If there's exactly one match, auto-select it (but don't auto-load on every keystroke unless it's unique)
        if (q && visible === 1 && firstMatch && firstMatch.value) {
          s.value = firstMatch.value;
        }
      };

      // Keyboard helpers: Enter selects the current/first match, ArrowDown jumps into the list
      search.onkeydown = (e) => {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          s.focus();
          return;
        }
        if (e.key === 'Enter') {
          e.preventDefault();
          // If something is selected, confirm it
          const v = s.value;
          if (v) {
            s.dispatchEvent(new Event('change'));
            resetPortSearchUI();
            search.blur();
          }
        }
      };

      // Close suggestion list when leaving the search box
      search.onblur = () => {
        // slight delay to allow click into the list
        setTimeout(() => { try { s.size = 0; } catch {} }, 150);
      };
    }

    function resetPortSearchUI() {
      const search = document.getElementById('pSearch');
      search.value = "";
      const s = document.getElementById('portList');
      [...s.options].forEach((opt, idx) => { if (idx !== 0) opt.hidden = false; });
      try { s.size = 0; } catch {}
    }

    // ===== Favs =====
    function setFavButtonState() {
      const btn = document.getElementById('addFavBtn');
      if (!envData.id) {
        btn.classList.remove('active'); btn.classList.add('disabled');
        btn.disabled = true; btn.title = "";
        return;
      }
      const exists = favs.some(f => String(f.id) === String(envData.id));
      if (exists) {
        btn.classList.remove('active'); btn.classList.add('disabled');
        btn.disabled = true; btn.title = "Already a favourite";
      } else {
        btn.classList.add('active'); btn.classList.remove('disabled');
        btn.disabled = false; btn.title = "Add to favourites";
      }
    }

    function updateFavsUI() {
      document.getElementById('favList').innerHTML = favs.map(f => `
        <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
          <span onclick="handlePort('${f.id}')" style="cursor:pointer">üìç ${escapeHtml(f.name)}</span>
          <span onclick="remFav('${f.id}')" style="color:var(--red); cursor:pointer;">‚úï</span>
        </div>
      `).join('') || `<div class="muted" style="font-size:0.8rem;">No favourites yet.</div>`;
      setFavButtonState();
            renderMyIntel();
renderSessionBar();
      showQuickStartOnce();
    }

    window.remFav = (id) => {
      favs = favs.filter(x => x.id !== id);
      localStorage.setItem('aos_favs', JSON.stringify(favs));
      updateFavsUI();
      notify("Favourite removed");
    };

    // ===== Map =====
    function initMapOnce() {
      if (map) return;
      map = L.map('map').setView([53.6, -0.2], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      map.on('click', (e) => {
        const n = nearestPort(e.latlng.lat, e.latlng.lng);
        if (!n) return;
        resetPortSearchUI();
        document.getElementById('portList').value = String(n.id);
        handlePort(n.id);
        notify(`Selected: ${n.name}`);
      });
    }

    // ===== Flow / Pressure trend =====
    function classifyFlow(flowStr) {
      const n = parseFloat(String(flowStr).replace("kn",""));
      if (!isFinite(n)) return { label: "‚Äî", ok:false };
      if (n >= 1.5 && n <= 3.0) return { label: "Feeding zone", ok:true };
      if (n < 1.5) return { label: "Slow", ok:false };
      return { label: "Fast", ok:false };
    }

    function pressureTrend(portId, current) {
      const key = `aos_press_${portId}`;
      const prev = JSON.parse(localStorage.getItem(key) || "null");
      localStorage.setItem(key, JSON.stringify({ v: current, t: Date.now() }));

      if (!prev || typeof prev.v !== "number") return "‚Äî";
      const delta = current - prev.v;
      if (Math.abs(delta) < 0.5) return "Stable";
      return delta > 0 ? "Rising" : "Falling";
    }

    // ===== Tides outlook =====
    async function renderTideOutlook(portId) {
      const box = document.getElementById('tideOutlook');
      box.innerHTML = `<div class="muted">Loading 7-day tides‚Ä¶</div>`;

      try {
        const tr = await fetch(
          PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${portId}/TidalEvents?duration=7&subscription-key=${AD_KEY}`));
        const td = await tr.json();

        if (!Array.isArray(td) || !td.length) {
          box.innerHTML = `<div class="muted">No tide events returned.</div>`;
          return;
        }

        

        // Also update the main Tide HUD using the same 7‚Äëday data (more reliable than the 1‚Äëday fetch in some environments)
        try {
          const now0 = new Date();
          const events0 = td.map(e => ({...e, _dt:new Date(e.DateTime)})).sort((a,b)=>a._dt-b._dt);
          const next0 = events0.find(e => e._dt > now0);
          if (next0) {
            const type0 = String(next0.EventType || '').replace('Water','');
            const ht0 = (typeof next0.Height === 'number') ? next0.Height.toFixed(1) : "--";
            const eta0 = fmtDuration(next0._dt - now0);
            const dir0 = type0.toLowerCase().includes("high") ? "Rising" : "Falling";
            const a = document.getElementById('hTide');
            const b = document.getElementById('hTideD');
            if (a) a.innerText = `${ht0}m ${type0}`;
            if (b) b.innerText = `${dir0} ‚Äî in ${eta0}`;
          }
        } catch {}

const byDay = new Map();
        for (const e of td) {
          const dt = new Date(e.DateTime);
          const dayKey = dt.toDateString();
          const type = String(e.EventType || '').replace('Water','');
          const height = (typeof e.Height === 'number') ? e.Height.toFixed(1) + "m" : "--";
          const time = dt.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
          if (!byDay.has(dayKey)) byDay.set(dayKey, []);
          byDay.get(dayKey).push({ dt, time, type, height });
        }

        const days = [...byDay.entries()].sort((a,b) => new Date(a[0]) - new Date(b[0]));
        for (const [, list] of days) list.sort((a,b) => a.dt - b.dt);

        let html = `<table class="tide-table">
          <thead><tr><th style="width:28%;">Day</th><th>High</th><th>Low</th></tr></thead><tbody>`;

        for (const [dayKey, list] of days) {
          const dayLabel = new Date(dayKey).toLocaleDateString([], { weekday:'short', day:'2-digit', month:'short' });
          const highs = list.filter(x => x.type.toLowerCase().includes("high")).map(x => `${x.time} <span class="muted">${x.height}</span>`).join("<br>") || "‚Äî";
          const lows  = list.filter(x => x.type.toLowerCase().includes("low")).map(x => `${x.time} <span class="muted">${x.height}</span>`).join("<br>") || "‚Äî";
          html += `<tr>
            <td class="day-row">${dayLabel}</td>
            <td>${highs}</td>
            <td>${lows}</td>
          </tr>`;
        }

        html += `</tbody></table>`;
        box.innerHTML = html;
      } catch (err) {
        console.error(err);
        box.innerHTML = `<div class="muted">Failed to load tides.</div>`;
      }
    }

    // ===== Handle Port =====
    async function handlePort(id) {
      id = String(id);
      const p = allPorts.find(x => String(x.id) === id);
      if (!p) return;

      envData.id = id;
      envData.port = p.name;
      window.currentLat = p.lat;
      window.currentLon = p.lon;
      try { updateBiteCard(); } catch(e) {}

      // ‚úÖ Keep UI in sync regardless of selection method
      resetPortSearchUI();
      const sel = document.getElementById('portList');
      if (sel) sel.value = id;

      initMapOnce();
      map.setView([p.lat, p.lon], 13);
      if (marker) marker.setLatLng([p.lat, p.lon]);
      else marker = L.marker([p.lat, p.lon]).addTo(map);

      setFavButtonState();
      renderSessionBar();
      showQuickStartOnce();

      // Tide next event + ETA + rising/falling approx
      try {
        const tr = await fetch(
          PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${id}/TidalEvents?duration=1&subscription-key=${AD_KEY}`)
        );
        const td = await tr.json();
        const now = new Date();
        const events = Array.isArray(td) ? td.map(e => ({...e, _dt:new Date(e.DateTime)})).sort((a,b)=>a._dt-b._dt) : [];
        const next = events.find(e => e._dt > now);

        if (next) {
          const type = String(next.EventType || '').replace('Water','');
          const ht = (typeof next.Height === 'number') ? next.Height.toFixed(1) : "--";
          const eta = fmtDuration(next._dt - now);
          const dir = type.toLowerCase().includes("high") ? "Rising" : "Falling";
          envData.tideDir = dir;
          envData.tideETA = eta;
          envData.tide = `${ht}m ${type}`;

          document.getElementById('hTide').innerText = `${ht}m ${type}`;
          document.getElementById('hTideD').innerText = `${dir} ‚Äî in ${eta}`;
        } else {
          document.getElementById('hTide').innerText = "--";
          document.getElementById('hTideD').innerText = "--";
        }
      } catch (err) {
        console.error(err);
      }

      // Weather + Pressure + Flow label
      try {
        const wr = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${p.lat}&longitude=${p.lon}&current=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,surface_pressure`);
        const wd = await wr.json();

        const tempC = wd?.current?.temperature_2m;
        const code  = wd?.current?.weather_code;
        const windKmh = wd?.current?.wind_speed_10m;
        const gustKmh = wd?.current?.wind_gusts_10m;
        const windDir = wd?.current?.wind_direction_10m;
        const press = wd?.current?.surface_pressure;

        const tempTxt = (typeof tempC === 'number') ? `${tempC.toFixed(1)}¬∞C` : "--";
        const wxTxt = weatherCodeToText(code);
        const windMph = (typeof windKmh === 'number') ? (windKmh * 0.621371) : NaN;
        const gustMph = (typeof gustKmh === 'number') ? (gustKmh * 0.621371) : NaN;

        const windDirTxt = degToDir(windDir);
        const windTxt = isFinite(windMph) ? `${windDirTxt} ${windMph.toFixed(0)} mph` : "--";
        const gustTxt = isFinite(gustMph) ? `Gusts ${gustMph.toFixed(0)} mph` : "";

        envData.temp = tempTxt;
        envData.weather = wxTxt;
        envData.wind = windTxt;
        envData.gust = gustTxt;

        document.getElementById('hCond').innerText = `${tempTxt} ‚Äî ${wxTxt}`;
        document.getElementById('hWind').innerText = `üí® ${windTxt}`;
        const gustEl = document.getElementById('hGust');
        if (gustTxt) {
          gustEl.style.display = "block";
          gustEl.innerText = `‚ö†Ô∏è ${gustTxt}`;
        } else {
          gustEl.style.display = "none";
        }

        if (typeof press === 'number') {
          const trend = pressureTrend(id, press);
          envData.press = `${press.toFixed(1)} hPa`;
          document.getElementById('hPress').innerText = envData.press;
          document.getElementById('hPressD').innerText = trend;
        } else {
          document.getElementById('hPress').innerText = "--";
          document.getElementById('hPressD').innerText = "--";
        }


        // Moon (current)
        try{
          const mp = moonPhaseInfo(Date.now());
          envData.moon = mp;
          const mEl = document.getElementById('hMoon');
          const mdEl = document.getElementById('hMoonD');
          if (mEl) mEl.innerText = `${mp.emoji} ${mp.name}`;
          if (mdEl) mdEl.innerText = `${mp.illum}% illum ‚Äî age ${mp.ageDays}d`;
          window.currentMoonAgeDays = mp.ageDays;
        } catch {}

        // Flow placeholder (until you swap to a real current API)
        envData.flow = (1.5 + Math.random()).toFixed(1) + "kn";
        const fc = classifyFlow(envData.flow);
        document.getElementById('hFlow').innerText = envData.flow;
        document.getElementById('hFlowD').innerText = fc.ok ? "Feeding zone" : fc.label;

      } catch (err) {
        console.error(err);
      }

      renderTideOutlook(id);
    

      // Refresh My BiteWise Intel for the selected port
      try { renderMyIntel(); } catch {}
}
    window.handlePort = handlePort;

    // ===== Photo compression (Firestore-friendly) =====
    
    async function dataUrlToBlob(dataUrl){
      const res = await fetch(dataUrl);
      return await res.blob();
    }

    async function uploadCatchPhotoToStorage(uid, catchId, dataUrl){
      try{
        if (!uid || !catchId || !dataUrl || !String(dataUrl).startsWith("data:image/")) return null;
        const blob = await dataUrlToBlob(dataUrl);
        const type = blob.type || "image/jpeg";
        const ext = type.includes("png") ? "png" : "jpg";
        const path = `users/${uid}/catches/${catchId}.${ext}`;
        const refObj = sRef(storage, path);
        await uploadBytes(refObj, blob, { contentType: type });
        const url = await getDownloadURL(refObj);
        return { photoUrl: url, photoPath: path };
      } catch(e){
        return null;
      }
    }


    // ===== Offline-safe Storage ops queue (uploads + deletes) =====
    const STORAGE_OPS_KEY = "bw_storageOps_v1";

    function loadStorageOps() {
      try { return JSON.parse(localStorage.getItem(STORAGE_OPS_KEY) || "[]") || []; }
      catch(e){ return []; }
    }
    function saveStorageOps(ops) {
      try { localStorage.setItem(STORAGE_OPS_KEY, JSON.stringify(ops || [])); } catch(e){}
    }
    function enqueueStorageUpload(uid, catchId, dataUrl) {
      if (!uid || !catchId || !dataUrl) return;
      const ops = loadStorageOps();
      ops.push({ type:"upload", uid, catchId, dataUrl, createdAt: Date.now() });
      saveStorageOps(ops);
    }
    function enqueueStorageDelete(uid, path) {
      if (!uid || !path) return;
      const ops = loadStorageOps();
      // Avoid duplicate deletes
      if (!ops.some(o => o.type==="delete" && o.uid===uid && o.path===path)) {
        ops.push({ type:"delete", uid, path, createdAt: Date.now() });
        saveStorageOps(ops);
      }
    }

    async function processStorageOpsOnce() {
      const uid = auth.currentUser?.uid;
      if (!uid) return;

      let ops = loadStorageOps();
      if (!ops.length) return;

      // Only process ops for current user
      const mine = ops.filter(o => o.uid === uid);
      if (!mine.length) return;

      // Process deletes first to avoid orphaned files on replace/remove
      for (const op of mine.filter(o => o.type === "delete")) {
        try {
          await deleteObject(sRef(storage, op.path));
          ops = ops.filter(o => !(o.type==="delete" && o.uid===uid && o.path===op.path));
          saveStorageOps(ops);
        } catch(e) {
          // If offline or denied, keep for later
        }
      }

      // Then process uploads
      for (const op of mine.filter(o => o.type === "upload")) {
        try {
          const up = await uploadCatchPhotoToStorage(uid, op.catchId, op.dataUrl);
          if (up) {
            await updateDoc(doc(db, "catches", op.catchId), { ...up, photo:"", photoPending:false });
            ops = ops.filter(o => !(o.type==="upload" && o.uid===uid && o.catchId===op.catchId && o.createdAt===op.createdAt));
            saveStorageOps(ops);
          } else {
            // keep for later (uploadCatchPhotoToStorage returned null)
          }
        } catch(e) {
          // keep for later
        }
      }
    }

    // Use queued local photo as preview while upload is pending
    function getQueuedPhotoDataUrl(uid, catchId) {
      try {
        const ops = loadStorageOps();
        const it = ops.find(o => o.type==="upload" && o.uid===uid && o.catchId===catchId);
        return it ? it.dataUrl : "";
      } catch(e){ return ""; }
    }

    // One-time binding for online events
    let _storageOpsOnlineBound = false;
    function bindStorageOpsOnlineHandler() {
      if (_storageOpsOnlineBound) return;
      _storageOpsOnlineBound = true;
      window.addEventListener("online", () => { processStorageOpsOnce(); });
    }

async function fileToCompressedDataUrl(file, maxW=900, quality=0.72) {
      const img = await new Promise((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = URL.createObjectURL(file);
      });

      const scale = Math.min(1, maxW / img.width);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);

      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);

      URL.revokeObjectURL(img.src);
      return canvas.toDataURL('image/jpeg', quality);
    }

    // ===== PB by WEIGHT only =====
    function computePBMap(items) {
      const best = new Map();
      for (const c of items) {
        const sp = (c.sp || "").toUpperCase();
        const wt = Number(c.wt || 0);
        if (!best.has(sp)) best.set(sp, { wt, id:c.id });
        else if (wt > best.get(sp).wt) best.set(sp, { wt, id:c.id });
      }
      return best;
    }

    // ===== Share =====
    async function shareCatch(c) {
      const text =
`BiteWise Catch Log
Species: ${c.sp || ""}
Weight: ${c.wt || 0} lb
Length: ${c.len || 0} cm
Location: ${c.loc || ""}
Date: ${c.dt || ""} @ ${c.time || ""}
Weather: ${c.weather || ""}, ${c.temp || ""}, Wind ${c.wind || ""} ${c.gust ? "(" + c.gust + ")" : ""}
Pressure: ${c.press || c.baro || ""}
Tide: ${c.tide || ""}
Flow: ${c.flow || ""}
Notes: ${c.notes || ""}`.trim();

      // Try to include photo on mobile via Web Share (files)
      async function dataUrlToFile(dataUrl, filename){
        const m = String(dataUrl||"").match(/^data:(image\/[^;]+);base64,(.+)$/);
        if (!m) return null;
        const mime = m[1];
        const b64 = m[2];
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i);
        return new File([bytes], filename, {type:mime});
      }

      async function urlToFile(url, filename){
        try{
          const res = await fetch(url, {mode:'cors'});
          if (!res.ok) return null;
          const blob = await res.blob();
          const type = blob.type || 'image/jpeg';
          return new File([blob], filename, {type});
        } catch(e){ return null; }
      }

      if (navigator.share) {
        try{
          let file = null;
          const photo = c.photo || c.photoUrl || c.img || "";
          if (photo) {
            if (String(photo).startsWith("data:image/")) {
              file = await dataUrlToFile(photo, "angleros-catch.jpg");
            } else if (/^https?:\/\//i.test(photo)) {
              file = await urlToFile(photo, "angleros-catch.jpg");
            }
          }

          if (file && navigator.canShare && navigator.canShare({ files:[file] })) {
            await navigator.share({ title:"BiteWise Catch", text, files:[file] });
          } else {
            await navigator.share({ title:"BiteWise Catch", text });
            if (photo && !file) notify("Photo couldn't be attached on this device.");
          }
          return;
        } catch(e){
          // fall through to clipboard
        }
      }

      navigator.clipboard?.writeText(text)
        .then(() => notify("Copied to clipboard"))
        .catch(() => notify("Share not supported"));
    }
    window.shareCatchById = (id) => {
      const c = catches.find(x => x.id === id);
      if (c) shareCatch(c);
    };

    // ===== Delete =====
    window.delCatch = async (id) => {
      if (!confirm("Delete record?")) return;

      // Best-effort delete photo from Firebase Storage first (if stored)
      try {
        const c = catches.find(x => x.id === id);
        const path = c?.photoPath || "";
        if (path) {
          try { await deleteObject(sRef(storage, path)); } catch(e) {}
        }
      } catch(e) {}

      await deleteDoc(doc(db, "catches", id));
      notify("Record deleted");
    };

    
    // ===== Session Engine (one active session) =====
    const SessionEngine = (() => {
      const KEY = "aos_sessions_v1";
      const now = () => Date.now();
      const uid = () => (crypto.randomUUID ? crypto.randomUUID() : String(now()) + Math.random().toString(16).slice(2));

      const read = () => { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } };
      const write = (rows) => localStorage.setItem(KEY, JSON.stringify(rows));

      const getActive = () => read().find(s => !s.endAt) || null;

      const start = ({ port="", lat=null, lon=null, acc=null } = {}) => {
        const rows = read().map(s => s.endAt ? s : ({ ...s, endAt: now(), updatedAt: now() })); // auto-end any active
        const s = {
          id: "sess_" + uid(),
          startAt: now(),
          endAt: null,
          port,
          lat, lon, acc,
          createdAt: now(),
          updatedAt: now()
        };
        rows.push(s);
        write(rows);
        return s;
      };

      const end = (id=null) => {
        const rows = read();
        const s = id ? rows.find(x => x.id === id) : rows.find(x => !x.endAt);
        if (!s || s.endAt) return s || null;
        s.endAt = now();
        s.updatedAt = now();
        
        // Auto-tag session on end
        try {
          const sessionCatches = catches.filter(c => c.sessionId === s.id);
          const tags = computeSessionTags(s, sessionCatches);
          s.tags = tags;
          s.tagSummary = tags.join(" ‚Ä¢ ");
        } catch(e) {}
write(rows);
        return s;
      };

      const ensureActive = (meta={}) => getActive() || start(meta);

      const durationMs = (s) => ( (s.endAt || now()) - s.startAt );
      const durationLabel = (ms) => {
        const mins = Math.max(0, Math.round(ms/60000));
        const h = Math.floor(mins/60), m = mins%60;
        return h ? `${h}h ${m}m` : `${m}m`;
      };

      return { read, write, getActive, start, end, ensureActive, durationMs, durationLabel };
    })();

    // ===== Session auto-tags =====
    function _hourLocal(ms){ try { return new Date(ms).getHours(); } catch { return 12; } }
    function _todTag(startMs, endMs){
      const h = _hourLocal(startMs);
      if (h >= 4 && h < 8) return "dawn";
      if (h >= 18 && h < 22) return "dusk";
      if (h >= 22 || h < 4) return "night";
      return "day";
    }
    function _mode(arr){
      const m = {};
      for (const v of arr){ if (!v) continue; m[v]=(m[v]||0)+1; }
      let best=null, bestN=0;
      for (const [k,n] of Object.entries(m)){ if (n>bestN){ best=k; bestN=n; } }
      return best;
    }
    function _avg(nums){
      const a = nums.filter(n => Number.isFinite(n));
      if (!a.length) return null;
      return a.reduce((s,x)=>s+x,0)/a.length;
    }
    function _inWindow(ms, w){
      if (!w?.start || !w?.end) return false;
      const t = ms;
      return t >= w.start.getTime() && t <= w.end.getTime();
    }

    function computeSessionTags(session, sessionCatches){
      const tags = [];
      if (!session) return tags;

      // Time-of-day
      tags.push(_todTag(session.startAt, session.endAt || Date.now()));

      // Multi-species
      const species = [...new Set((sessionCatches||[]).map(c => (c.sp||"").toUpperCase()).filter(Boolean))];
      if (species.length >= 2) tags.push("multi-species");
      else if (species.length === 1) tags.push(species[0].toLowerCase());

      // Tide phase + stage
      const phases = (sessionCatches||[]).map(c => (c.tideCtx?.phase || "").toLowerCase());
      const domPhase = _mode(phases);
      if (domPhase === "rising") tags.push("flooding");
      if (domPhase === "falling") tags.push("ebbing");

      const prog = (sessionCatches||[]).map(c => Number(c.tideCtx?.progressPct));
      const avgProg = _avg(prog);
      if (avgProg !== null) {
        if (avgProg < 33) tags.push("early tide");
        else if (avgProg < 67) tags.push("mid tide");
        else tags.push("late tide");
      } else {
        // fallback: before/after label
        const rels = (sessionCatches||[]).map(c => (c.tideCtx?.relation || "").toLowerCase());
        const domRel = _mode(rels);
        if (domRel) {
          if (domRel.includes("before hw")) tags.push("to HW");
          else if (domRel.includes("before lw")) tags.push("to LW");
          else if (domRel.includes("after hw")) tags.push("after HW");
          else if (domRel.includes("after lw")) tags.push("after LW");
        }
      }

      // Weather quick tags
      const wtxt = (sessionCatches||[]).map(c => (c.weather||"").toLowerCase()).join(" ");
      if (wtxt.includes("rain")) tags.push("rain");
      else if (wtxt.includes("overcast")) tags.push("overcast");
      else if (wtxt.includes("clear")) tags.push("clear");

      // Solunar overlap (requires getSolunarWindows + location)
      try{
        const lat = session.lat ?? window.currentLat ?? envData?.lat ?? null;
        const lon = session.lon ?? window.currentLon ?? envData?.lon ?? null;
        const solFn = (typeof window.getSolunarWindows === "function") ? window.getSolunarWindows : null;
        if (solFn && lat !== null && lon !== null) {
          const day = new Date(session.startAt);
          const sol = solFn(day, lat, lon);
          if (sol) {
            const majors = [
              {start: sol.majorStart1, end: sol.majorEnd1},
              {start: sol.majorStart2, end: sol.majorEnd2},
            ];
            const minors = [
              {start: sol.minorStart1, end: sol.minorEnd1},
              {start: sol.minorStart2, end: sol.minorEnd2},
            ];
            const inMajor = (sessionCatches||[]).some(c => _inWindow(Number(c.caughtAt||c.timestamp||0), majors[0]) || _inWindow(Number(c.caughtAt||c.timestamp||0), majors[1]));
            const inMinor = (sessionCatches||[]).some(c => _inWindow(Number(c.caughtAt||c.timestamp||0), minors[0]) || _inWindow(Number(c.caughtAt||c.timestamp||0), minors[1]));
            if (inMajor) tags.push("solunar major");
            else if (inMinor) tags.push("solunar minor");
          }
        }
      } catch(e){}

      // Deduplicate & limit
      const seen = new Set();
      const out = [];
      for (const t of tags){
        const k = (t||"").trim();
        if (!k) continue;
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(k);
      }
      return out.slice(0, 6);
    }

    function getSessionMetaFromEnv(){
      return {
        port: envData.port || "",
        lat: envData.lat ?? null,
        lon: envData.lon ?? null,
        acc: envData.acc ?? null
      };

      // Refresh My BiteWise Intel for the selected port
      try { renderMyIntel(); } catch {}

    }

    function formatLocal(dt){
      try {
        return new Date(dt).toLocaleString([], { year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });
      } catch { return ""; }
    }

    function buildSessionSummaryHtml() {
      const s = SessionEngine.getActive();
      if (!s) return `<div class="muted">No active session. Press <b>START SESSION</b> or save a catch to auto-start.</div>`;

      // Use in-memory catches array filtered by sessionId (if present)
      const sessionCatches = catches.filter(c => c.sessionId === s.id);
      const totalCount = sessionCatches.length;
      const totalWeight = sessionCatches.reduce((sum, c) => sum + (Number(c.wt)||0), 0);

      const bySpecies = {};
      for (const c of sessionCatches) {
        const k = (c.sp || "UNKNOWN").toUpperCase();
        bySpecies[k] = (bySpecies[k] || 0) + 1;
      }
      const rows = Object.entries(bySpecies)
        .sort((a,b)=>b[1]-a[1])
        .map(([sp,n]) => `<div class="row" style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);">
          <div><b>${escapeHtml(sp)}</b></div><div>${n}</div>
        </div>`).join("");

      return `
        <div class="card" style="padding:10px;">
          <div><b>Session:</b> ${escapeHtml(s.port || "‚Äî")}</div>
          <div><b>Start:</b> ${escapeHtml(formatLocal(s.startAt))}</div>
          <div><b>Duration:</b> ${escapeHtml(SessionEngine.durationLabel(SessionEngine.durationMs(s)))}</div>
          <div><b>Tags:</b> ${escapeHtml((s.tags && s.tags.length) ? s.tags.join(" ‚Ä¢ ") : (computeSessionTags(s, sessionCatches).join(" ‚Ä¢ ") || "‚Äî"))}</div>
          <div style="margin-top:6px;"><b>Total caught:</b> ${totalCount}</div>
          <div><b>Total weight:</b> ${totalWeight.toFixed(1)} lb</div>
        </div>
        <div style="margin-top:10px;">
          <div class="intel-header" style="margin:0 0 6px;">Species breakdown</div>
          ${rows || `<div class="muted">No catches in this session yet.</div>`}
        </div>
      `;
    }

    function updateSessionBadge(){
      const s = SessionEngine.getActive();
      const n = s ? catches.filter(c => c.sessionId === s.id).length : 0;
      const btn = document.getElementById('totalsBtn');
      if (btn) btn.textContent = `üß≠ SESSION: ${n}`;
    }


    function renderSessionBar(){
      const s = SessionEngine.getActive();
      const titleEl = document.getElementById('sessionTitle');
      const subEl = document.getElementById('sessionSub');
      const startBtn = document.getElementById('sessionStartBtn');
      const endBtn = document.getElementById('sessionEndBtn');

      if (!titleEl || !subEl || !startBtn || !endBtn) return;

      if (!s){
        titleEl.innerText = "No active session";
        subEl.innerText = "Tap START to begin (auto-starts when you save your first catch).";
        startBtn.style.display = "inline-flex";
        endBtn.style.display = "none";
        return;
      }

      const count = catches.filter(c => c.sessionId === s.id).length;
      const dur = SessionEngine.durationLabel(SessionEngine.durationMs(s));
      const place = (s.port && s.port !== "Unknown") ? s.port : (envData.port || "Unknown");
      titleEl.innerText = `Session active ‚Äî ${dur}`;
      subEl.innerText = `${place} ‚Äî ${count} catch${count === 1 ? "" : "es"}`;
      startBtn.style.display = "none";
      endBtn.style.display = "inline-flex";
    }

    function helpHtml(){
      
      return `
        <div style="font-size:0.9rem; line-height:1.65;">
          <div class="intel-header" style="margin-top:0;">Quick start</div>
          <ol style="margin:0 0 12px 18px; padding:0;">
            <li>Pick a <b>location</b> (favourite ‚òÖ, map tap, or the port dropdown).</li>
            <li>Check the <b>HUD cards</b> (Weather / Tide / Flow / Pressure / Moon / Bite).</li>
            <li>Log a catch in <b>New Catch</b> to build your <b>My BiteWise Intel</b> over time.</li>
          </ol>

          <div class="intel-header">Locations</div>
          <ul class="intel-list" style="margin-bottom:12px;">
            <li><b>‚òÖ Favourites</b>: Save your regular marks for one‚Äëtap selection.</li>
            <li><b>Map</b>: Tap the map to move the marker. Use GPS to jump to your current position.</li>
            <li><b>Port dropdown</b>: Quickly switch to a known port (also updates tide/weather sources).</li>
          </ul>

          <div class="intel-header">HUD cards</div>
          <div class="intel-grid" style="margin-bottom:12px;">
            <div><b>Weather</b><br><span class="muted">Current conditions + forecast for the selected location.</span></div>
            <div><b>Tide</b><br><span class="muted">Next tide event + timing and a 7‚Äëday outlook (where available).</span></div>
            <div><b>Flow</b><br><span class="muted">Simple read on movement / ‚Äúfeeding zone‚Äù cues based on tide state.</span></div>
            <div><b>Pressure</b><br><span class="muted">Barometric pressure and trend (stable / rising / falling).</span></div>
            <div><b>Moon</b><br><span class="muted">Phase, illumination, and moon age for today.</span></div>
            <div><b>Bite</b><br><span class="muted">Solunar bite windows (Major/Minor). Shows <b>active</b> windows and time to next.</span></div>
          </div>

          <div class="intel-header">My BiteWise Intel</div>
          <ul class="intel-list" style="margin-bottom:12px;">
            <li><b>Range filter</b>: Use <b>Last 7 / 30 / 90 / All‚Äëtime</b> to change what history is analysed.</li>
            <li><b>Transparency</b>: Each insight shows <b>based on X catches</b>. If there isn‚Äôt enough data, you‚Äôll see <b>Not enough data yet</b>.</li>
            <li><b>What it learns</b>: Patterns like best tide window, rising vs falling, moon phase, and more (as your log grows).</li>
          </ul>

          <div class="intel-header">Catches & history</div>
          <div class="intel-grid" style="margin-bottom:12px;">
            <div><b>New Catch</b><br><span class="muted">Log species, weight/length, notes, and photo. More logs = better intel.</span></div>
            <div><b>Previous catches</b><br><span class="muted">Your recent log. Edit or delete entries anytime.</span></div>
            <div><b>History Calendar</b><br><span class="muted">Jump to a day to review what you caught and the conditions.</span></div>
            <div><b>Session</b><br><span class="muted">Use <b>üß≠ SESSION</b> for quick totals and session timing.</span></div>
          </div>

          <div class="intel-header">Tips</div>
          <ul class="intel-list" style="margin-bottom:12px;">
            <li>If <b>Bite</b> says ‚ÄúLocation needed‚Äù, select a port or favourite (or enable GPS).</li>
            <li>Use short, consistent notes (e.g. ‚Äú2h after low‚Äù, ‚Äúweed on flood‚Äù) ‚Äî they become searchable patterns later.</li>
          </ul>

          <div style="margin-top:14px; display:flex; gap:10px;">
            <button class="btn-main" id="helpGotItBtn" style="margin:0;">GOT IT</button>
          </div>
          <div style="margin-top:8px; font-size:0.8rem;" class="muted">
            Tip: Help is always available from the <b>‚ùì</b> button.
          </div>
        </div>
      `;

    }

    // ===== 7-day tide planner =====
    function fmtTimeLocal(dtStr){
      const d = new Date(dtStr);
      return d.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
    }

    function dayKeyFromDate(dt){
      return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
    }

    function groupEventsByDay(events){
      const by = {};
      for (const e of (events || [])){
        if (!e || !e.DateTime) continue;
        const d = new Date(e.DateTime);
        const key = dayKeyFromDate(d);
        (by[key] ||= []).push(e);
      }
      for (const k of Object.keys(by)){
        by[k].sort((a,b)=> new Date(a.DateTime) - new Date(b.DateTime));
      }
      return by;
    }

    function buildPlannerHtml(){
      const by = groupEventsByDay(tideCache.events || []);
      const today = new Date();
      const days = [];
      for (let i=0;i<7;i++){
        const d = new Date(today.getFullYear(), today.getMonth(), today.getDate()+i);
        days.push(d);
      }

      const items = days.map(d => {
        const key = dayKeyFromDate(d);
        const ev = by[key] || [];
        const label = d.toLocaleDateString([], { weekday:'short', day:'2-digit', month:'short' });
        const hw = ev.filter(e => e.EventType === "HighWater").slice(0,2)
          .map(e => `${fmtTimeLocal(e.DateTime)} (${(typeof e.Height==="number"?e.Height.toFixed(1):"--")}m)`).join(" ‚Ä¢ ");
        const lw = ev.filter(e => e.EventType === "LowWater").slice(0,2)
          .map(e => `${fmtTimeLocal(e.DateTime)} (${(typeof e.Height==="number"?e.Height.toFixed(1):"--")}m)`).join(" ‚Ä¢ ");

        const body = ev.length
          ? `<div style="display:grid; gap:6px;">
               <div><b>High:</b> <span class="muted">${hw || "‚Äî"}</span></div>
               <div><b>Low:</b> <span class="muted">${lw || "‚Äî"}</span></div>
             </div>`
          : `<div class="muted">No tide events available.</div>`;

        return `
          <div class="card" style="padding:10px; margin-bottom:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
              <div style="font-weight:900;">${escapeHtml(label)}</div>
              <button class="btn-sub" data-tide-day="${key}" style="padding:8px 10px;">DETAILS</button>
            </div>
            <div style="margin-top:8px;">${body}</div>
          </div>
        `;
      }).join("");

      return `
        <div class="muted" style="margin-bottom:10px;">
          7-day tide planner for <b>${escapeHtml(envData.portName || envData.port || "selected port")}</b>.
        </div>
        ${items}
      `;
    }

    function showTideDayDetail(dateKey){
      const by = groupEventsByDay(tideCache.events);
      const ev = by[dateKey] || [];
      const [y,m,d] = dateKey.split('-').map(Number);
      const nice = new Date(y, m-1, d).toLocaleDateString([], { weekday:'long', year:'numeric', month:'short', day:'2-digit' });

      if (!ev.length){
        openModal("Tides", `<div class="muted">No tide events available for ${escapeHtml(nice)}.</div>`);
        return;
      }

      const rows = ev.map(e => {
        const t = fmtTimeLocal(e.DateTime);
        const h = (typeof e.Height === "number") ? e.Height.toFixed(2) : "--";
        const type = (e.EventType === "HighWater") ? "High" : "Low";
        return `<div class="row" style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,.06);">
          <div><b>${type}</b> ‚Ä¢ ${t}</div><div>${h} m</div>
        </div>`;
      }).join("");

      openModal("Tides ‚Ä¢ " + nice, `<div>${rows}</div>`);
    }

    async function openTidePlanner(){
      // Resolve selected station id
      let portId = envData.portId || envData.id || document.getElementById('portList')?.value || null;
      if (!portId){
        const wanted = (envData.portName || envData.port || "").trim().toLowerCase();
        const sel = document.getElementById('portList');
        if (wanted && sel){
          const opt = Array.from(sel.options || []).find(o => (o.textContent || "").trim().toLowerCase() === wanted);
          if (opt && opt.value) portId = opt.value;
        }
      }
      if (!portId){
        notify("Select a port first");
        return;
      }
      envData.portId = portId;
      envData.id = portId;

      // Ensure cache is fresh (10 minutes)
      if (!tideCache.events?.length || tideCache.portId !== portId || (Date.now() - tideCache.fetchedAt) > 10*60*1000){
        try {
          const url = PROXY + encodeURIComponent(`https://admiraltyapi.azure-api.net/uktidalapi/api/V1/Stations/${portId}/TidalEvents?duration=7&subscription-key=${AD_KEY}`);
          const resp = await fetch(url);
          if (!resp.ok){
            const txt = await resp.text();
            console.warn("Tide fetch failed", resp.status, txt.slice(0,200));
            notify("Couldn't load tides");
            return;
          }
          const ctype = resp.headers.get('content-type') || '';
          if (!ctype.includes('application/json')){
            const txt = await resp.text();
            console.warn("Non-JSON tide response", txt.slice(0,200));
            notify("Couldn't load tides");
            return;
          }
          const td = await resp.json();
          tideCache.portId = portId;
          tideCache.events = Array.isArray(td) ? td.slice() : [];
          tideCache.fetchedAt = Date.now();
        } catch (e){
          console.warn(e);
          notify("Couldn't load tides");
          return;
        }
      }

      openModal("7-day planner", buildPlannerHtml());
      setTimeout(() => {
        document.querySelectorAll('[data-tide-day]').forEach(btn => {
          btn.onclick = () => showTideDayDetail(btn.getAttribute('data-tide-day'));
        });
      }, 0);
    }


    function showHelp(){
      openModal("Help", helpHtml());
      setTimeout(() => {
        const b = document.getElementById('helpGotItBtn');
        if (b) b.onclick = () => closeModal();
      }, 0);
    }

    function showQuickStartOnce(){
      const key = "aos_help_seen_v1";
      if (localStorage.getItem(key) === "1") return;
      showHelp();
      setTimeout(() => {
        const b = document.getElementById('helpGotItBtn');
        if (b) b.onclick = () => { localStorage.setItem(key, "1"); closeModal(); };
      }, 0);
    }


    // ===== Inline edit =====
    const editState = new Map();

    window.startEdit = (id) => {
      const c = catches.find(x => x.id === id);
      if (!c) return;
      editState.set(id, { photo: (c.photoUrl || c.photo || "") });
      renderDiary();
    };
    window.cancelEdit = (id) => { editState.delete(id); renderDiary(); };

    // Remove photo during edit (clears current photo and queues Storage delete on save)
    window.removeEditPhoto = (id) => {
      const cur = editState.get(id) || {};
      editState.set(id, { ...cur, photo:"", removePhoto:true });
      renderDiary();
    };


    window.saveEdit = async (id) => {
      const c = catches.find(x => x.id === id);
      if (!c) return;

      const sp = document.getElementById(`es_${id}`).value.trim();
      const wt = Number(document.getElementById(`ew_${id}`).value || 0);
      const len = Number(document.getElementById(`el_${id}`).value || 0);
      const notes = document.getElementById(`en_${id}`).value || "";
      const staged = editState.get(id) || {};
      const stagedPhoto = staged.photo ?? "";
      const wantsRemovePhoto = !!staged.removePhoto;

      // If user picked a new photo, it will be a data URL (we compress on select)
      const hasNewPhoto = String(stagedPhoto || "").startsWith("data:image/");

      let patch = {
        sp: sp.toUpperCase(),
        wt,
        len,
        notes,
        updatedAt: Date.now()
      };

      // Remove existing photo (and optionally queue delete if offline)
      if (wantsRemovePhoto && !hasNewPhoto) {
        const uid = auth.currentUser?.uid;
        if (c.photoPath) {
          if (navigator.onLine) {
            try { await deleteObject(sRef(storage, c.photoPath)); } catch(e) {}
          } else {
            enqueueStorageDelete(uid, c.photoPath);
          }
        }
        patch = { ...patch, photoUrl:"", photoPath:"", photo:"", photoPending:false };
      }

      // Replace photo in Storage if a new one was selected
      if (hasNewPhoto) {
        const uid = auth.currentUser?.uid;

        // If replacing an existing Storage photo, delete it (or queue delete)
        if (c.photoPath) {
          if (navigator.onLine) {
            try { await deleteObject(sRef(storage, c.photoPath)); } catch(e) {}
          } else {
            enqueueStorageDelete(uid, c.photoPath);
          }
        }

        // Mark pending; if online try now, else queue upload
        patch = { ...patch, photoPending: true, photoUrl:"", photoPath:"", photo:"" };

        if (navigator.onLine) {
          try {
            const up = await uploadCatchPhotoToStorage(uid, id, stagedPhoto);
            if (up) patch = { ...patch, ...up, photo:"", photoPending:false };
            else enqueueStorageUpload(uid, id, stagedPhoto);
          } catch(e) {
            enqueueStorageUpload(uid, id, stagedPhoto);
          }
        } else {
          enqueueStorageUpload(uid, id, stagedPhoto);
        }
      }

      await updateDoc(doc(db, "catches", id), patch);

      editState.delete(id);
      renderDiary();
      notify("Record updated");
    };

    // ===== Diary =====
    
    // ===== Tide display (catch cards) =====
    function _tideEventLabel(et){
      if (et === "HighWater") return "HW";
      if (et === "LowWater") return "LW";
      return "";
    }

    function _fmtMins(mins){
      if (mins === null || mins === undefined || !Number.isFinite(mins)) return "";
      const m = Math.abs(Math.round(mins));
      const h = Math.floor(m/60);
      const mm = m % 60;
      if (h <= 0) return `${mm}m`;
      return `${h}h ${mm}m`;
    }

    function formatTideForCatch(c){
      const fallback = (c?.tideHud?.summary || c?.tide || c?.tideHud?.detail || "").trim();

      // If saved ctx is incomplete, try to recompute now using cached tide events.
      let ctx = c?.tideCtx || null;
      try {
        const ms = Number(c?.caughtAt ?? c?.timestamp ?? c?.createdAt);
        const pid = (c?.portId || c?.idPort || c?.stationId || "").toString();
        if (Number.isFinite(ms) && typeof tideContextFor === "function") {
          const fresh = tideContextFor(ms, pid);
          // Prefer fresh if it has richer fields (relation/progress/minsToNext)
          if (fresh && (fresh.relation || fresh.progressPct !== null || fresh.minsToNextEvent !== null)) {
            ctx = fresh;
          }
        }
      } catch(e){}

      if (!ctx) return fallback || "--";

      // Backwards-compatible field support (older ctx schema)
      const phase = (ctx.phase || "").trim(); // Rising/Falling

      // relation: may be missing on old saves ‚Äî derive from nextType/summary
      let relation = (ctx.relation || "").trim();
      if (!relation) {
        const nt = (ctx.nextType || "").toString().toLowerCase(); // "high"/"low"
        if (nt === "high") relation = "Before HW";
        else if (nt === "low") relation = "Before LW";
      }

      // mins to next: new schema minsToNextEvent; old schema minsToNext / minsToNearestEvent (if next not known)
      let minsToNext = null;
      if (ctx.minsToNextEvent !== null && ctx.minsToNextEvent !== undefined && Number.isFinite(ctx.minsToNextEvent)) minsToNext = ctx.minsToNextEvent;
      else if (ctx.minsToNext !== null && ctx.minsToNext !== undefined && Number.isFinite(ctx.minsToNext)) minsToNext = ctx.minsToNext;
      else if (ctx.minsToNearestEvent !== null && ctx.minsToNearestEvent !== undefined && Number.isFinite(ctx.minsToNearestEvent) && ctx.minsToNearestEvent >= 0) minsToNext = ctx.minsToNearestEvent;

      // progress: only available when we know prev+next ‚Äî otherwise leave null
      const pct = (ctx.progressPct !== null && ctx.progressPct !== undefined && Number.isFinite(ctx.progressPct)) ? Math.round(ctx.progressPct) : null;

      // Determine next event label
      let nextLabel = _tideEventLabel(ctx.nextEventType);
      if (!nextLabel) {
        const nt = (ctx.nextType || "").toString().toLowerCase();
        if (nt === "high") nextLabel = "HW";
        else if (nt === "low") nextLabel = "LW";
      }

      const parts = [];
      if (phase) parts.push(phase);
      if (pct !== null) parts.push(`${pct}%`);
      if (relation) parts.push(relation);

      if (minsToNext !== null) {
        parts.push(`${_fmtMins(minsToNext)} to ${nextLabel || "next"}`);
      }

      const out = parts.filter(Boolean).join(" ‚Ä¢ ");
      return out || (fallback || "--");
    }

function renderDiary() {
      const list = selectedDate ? catches.filter(c => c.dt === selectedDate) : catches;
      const pbMap = computePBMap(catches);

      document.getElementById('diary').innerHTML = list.map(c => {
        const sp = (c.sp || "").toUpperCase();
        const isPB = pbMap.get(sp)?.id === c.id;
        const editing = editState.has(c.id);
        const staged = editState.get(c.id) || {};
        const queuedPhoto = (!staged.photo && c.photoPending) ? getQueuedPhotoDataUrl(currentUid, c.id) : "";
        const photoToShow = staged.removePhoto ? "" : (staged.photo ?? c.photoUrl ?? queuedPhoto ?? c.photo ?? "");

        if (!editing) {
          const pbBadge = isPB ? `<span class="pb-badge">PB</span>` : "";
          const photoHtml = photoToShow ? `<img class="thumb" src="${photoToShow}" onclick="openModal('Photo', '<img src=&quot;${photoToShow}&quot; style=&quot;width:100%;border-radius:12px;border:1px solid var(--border);&quot;>')">` : "";

          return `
            <div class="card ${isPB ? "pb" : ""}">
              <div style="display:flex; justify-content:space-between; align-items:start; gap:10px;">
                <div style="flex:1;">
                  <b style="color:var(--sea);">${escapeHtml(sp)}</b>${pbBadge}
                  <div style="margin-top:2px;"><small>${escapeHtml(String(c.wt ?? 0))}lb ‚Äî ${escapeHtml(String(c.len ?? 0))}cm</small></div>
                  <small style="color:var(--gold);">${escapeHtml(c.loc || '--')} | ${escapeHtml(c.dt || '--')} @ ${escapeHtml(c.time || '--:--')}</small>
                </div>

                <div class="inline-actions">
                  <button class="btn-sub" onclick="startEdit('${c.id}')" style="padding:8px;">‚úèÔ∏è Edit</button>
                  <button class="btn-sub" onclick="shareCatchById('${c.id}')" style="padding:8px;">üì§ Share</button>
                  <button class="btn-sub" onclick="delCatch('${c.id}')" style="padding:8px; border-color:var(--red); color:var(--red);">üóëÔ∏è</button>
                </div>
              </div>

              <div class="catch-meta" style="margin-top:10px;">
                <span>üå°Ô∏è ${escapeHtml(c.temp || '--')} ‚Äî ${escapeHtml(c.weather || '--')}</span>
                <span>üí® ${escapeHtml(c.wind || '--')} ${c.gust ? `‚Ä¢ <span style="color:var(--red); font-weight:900;">${escapeHtml(c.gust)}</span>` : ""}</span>
                <span>üß≠ Pressure: ${escapeHtml(c.press || c.baro || '--')}</span>
                <span>üåä Tide: ${escapeHtml(formatTideForCatch(c))}</span>
                <span>üöÄ Flow: ${escapeHtml(c.flow || '--')}</span>
                <span>üìù Notes: ${c.notes ? escapeHtml(c.notes) : '--'}</span>
              </div>

              ${photoHtml}
            </div>
          `;
        }

        return `
          <div class="card ${isPB ? "pb" : ""}">
            <div style="display:flex; justify-content:space-between; align-items:start; gap:10px;">
              <div style="flex:1;">
                <b style="color:var(--sea);">EDIT</b>
                <div class="muted" style="font-size:0.75rem; margin-top:4px;">
                  Original preserved: ${escapeHtml(c.dt || "")} @ ${escapeHtml(c.time || "")}
                </div>
              </div>
              <div class="inline-actions">
                <button class="btn-sub" onclick="cancelEdit('${c.id}')" style="padding:8px;">Cancel</button>
                <button class="btn-sub" onclick="saveEdit('${c.id}')" style="padding:8px; border-color:var(--sea); color:var(--sea);">Save</button>
              </div>
            </div>

            <div class="edit-grid" style="margin-top:12px;">
              <input id="es_${c.id}" value="${escapeHtml(c.sp || "")}" placeholder="Species" />
              <input id="ew_${c.id}" type="number" value="${escapeHtml(String(c.wt ?? 0))}" placeholder="Weight (lb)" />
            </div>
            <div class="edit-grid">
              <input id="el_${c.id}" type="number" value="${escapeHtml(String(c.len ?? 0))}" placeholder="Length (cm)" />
              <div class="photo-actions">
  <input id="ep_${c.id}" type="file" class="photo-input" accept="image/*" />
  <label for="ep_${c.id}" class="photo-btn" title="Replace photo" aria-label="Replace photo">üì∑</label>
  <button type="button" class="photo-btn" onclick="removeEditPhoto('${c.id}')" title="Remove photo" aria-label="Remove photo">üóëÔ∏è</button>
</div>
            </div>
            <textarea id="en_${c.id}" style="height:80px;" placeholder="Notes...">${escapeHtml(c.notes || "")}</textarea>

            <div class="muted" style="font-size:0.75rem;">Replace photo (optional). Photos are auto-compressed.</div>
            ${photoToShow ? `<img class="thumb" src="${photoToShow}" onclick="openModal('Photo', '<img src=&quot;${photoToShow}&quot; style=&quot;width:100%;border-radius:12px;border:1px solid var(--border);&quot;>')">` : `<div class="muted" style="font-size:0.8rem; margin-top:10px;">No photo</div>`}
          </div>
        `;
      }).join('') || `<div style="text-align:center; opacity:0.5;">No records</div>`;

      for (const c of list) {
        if (!editState.has(c.id)) continue;
        const input = document.getElementById(`ep_${c.id}`);
        if (!input) continue;
        input.onchange = async () => {
          const file = input.files?.[0];
          if (!file) return;
          const dataUrl = await fileToCompressedDataUrl(file, 900, 0.72);
          editState.set(c.id, { ...(editState.get(c.id)||{}), photo: dataUrl, removePhoto:false });
          renderDiary();
        };
      }
    }

    // ===== Calendar =====
    function renderCalendar() {
      const g = document.getElementById('calGrid');
      g.innerHTML = "";
      const now = new Date();
      const m = now.getMonth();
      const y = now.getFullYear();
      const first = new Date(y, m, 1).getDay() || 7;
      const total = new Date(y, m + 1, 0).getDate();

      for (let i = 1; i < first; i++) g.appendChild(document.createElement('div'));

      for (let d = 1; d <= total; d++) {
        const dStr = `${String(d).padStart(2,'0')}/${String(m+1).padStart(2,'0')}/${y}`;
        const div = document.createElement('div');
        div.className = `cal-day ${catches.some(c => c.dt === dStr) ? 'has-catch' : ''} ${selectedDate === dStr ? 'selected' : ''}`;
        div.innerText = d;
        div.onclick = () => {
          if (selectedDate === dStr) {
            // Clear selection -> revert to today view
            selectedDate = todayStr();
            userSelectedDate = false;
          } else {
            selectedDate = dStr;
            userSelectedDate = true;
          }
          renderCalendar();
          renderDiary();
        };
        g.appendChild(div);
      }
    }

    // ===== Totals (today only) =====
    function buildTodaySummaryHtml() {
      const dtStr = todayStr();
      const dayCatches = catches.filter(c => c.dt === dtStr);
      const totalCount = dayCatches.length;
      const totalWeight = dayCatches.reduce((sum, c) => sum + Number(c.wt || 0), 0);

      const bySpecies = new Map();
      for (const c of dayCatches) {
        const sp = (c.sp || "UNKNOWN").toUpperCase();
        const obj = bySpecies.get(sp) || { count: 0, weight: 0 };
        obj.count += 1;
        obj.weight += Number(c.wt || 0);
        bySpecies.set(sp, obj);
      }

      const rows = [...bySpecies.entries()]
        .sort((a,b) => b[1].count - a[1].count)
        .map(([sp, v]) => `
          <div style="display:flex; justify-content:space-between; border-bottom:1px solid var(--border); padding:8px 0; font-size:0.85rem;">
            <div><b style="color:var(--sea)">${escapeHtml(sp)}</b> <span class="muted">x${v.count}</span></div>
            <div><span class="muted">${v.weight.toFixed(1)}lb</span></div>
          </div>
        `).join("");

      return `
        <div style="font-size:0.85rem; margin-bottom:8px;">
          <div><b>Date:</b> ${escapeHtml(dtStr)}</div>
          <div style="margin-top:6px;"><b>Total caught:</b> ${totalCount}</div>
          <div><b>Total weight:</b> ${totalWeight.toFixed(1)} lb</div>
        </div>
        <div style="margin-top:10px;">
          <div class="intel-header" style="margin:0 0 6px;">Species breakdown</div>
          ${rows || `<div class="muted">No catches recorded today.</div>`}
        </div>
      `;
    }

    // ===== Save catch =====
    
    // ===== My BiteWise Intel (personal insights) =====
    function moonPhaseInfo(dateMs){
      // Simple synodic month model (good enough for angling insights)
      const synodic = 29.53058867; // days
      const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14, 0); // 2000-01-06 18:14 UTC
      const days = (dateMs - knownNewMoon) / 86400000;
      let age = days % synodic;
      if (age < 0) age += synodic;

      const frac = age / synodic; // 0..1
      const idx = Math.floor((frac * 8) + 0.5) % 8; // 8 phases
      const phases = [
        {name:"New Moon", emoji:"üåë"},
        {name:"Waxing Crescent", emoji:"üåí"},
        {name:"First Quarter", emoji:"üåì"},
        {name:"Waxing Gibbous", emoji:"üåî"},
        {name:"Full Moon", emoji:"üåï"},
        {name:"Waning Gibbous", emoji:"üåñ"},
        {name:"Last Quarter", emoji:"üåó"},
        {name:"Waning Crescent", emoji:"üåò"},
      ];
      const p = phases[idx];
      const illum = (1 - Math.cos(2*Math.PI*frac)) / 2; // 0..1
      return { ...p, ageDays: Number(age.toFixed(1)), illum: Math.round(illum*100) };
    }

    function tideContextFor(dateMs, portId){
      try{
        const events = (tideCache && Array.isArray(tideCache.events)) ? tideCache.events : [];
        if (!events.length) return null;
        if (tideCache.portId && portId && tideCache.portId !== portId) return null;

        const t = new Date(dateMs).getTime();
        const parsed = events
          .filter(e => e && e.DateTime)
          .map(e => ({...e, _t: new Date(e.DateTime).getTime()}))
          .filter(e => Number.isFinite(e._t))
          .sort((a,b)=>a._t-b._t);

        if (!parsed.length) return null;

        // Find prev (last event <= t) and next (first event >= t)
        let next = parsed.find(e => e._t >= t) || null;
        let prev = null;
        for (let i=parsed.length-1;i>=0;i--){
          if (parsed[i]._t <= t){ prev = parsed[i]; break; }
        }

        // If only one side exists, fall back to "nearest" behaviour
        const nearest = next || prev;
        if (!nearest) return null;

        // Nearest (signed) minutes (positive before, negative after)
        const minsToNearest = Math.round((nearest._t - t) / 60000);

        // Build more meaningful context if we have BOTH prev and next
        let phase = "Unknown";
        let minsToNext = null;
        let minsSincePrev = null;
        let segmentMins = null;
        let progressPct = null;
        let relation = "";
        let bucket = "";

        const typeLabel = (et) => (et === "HighWater" ? "HW" : (et === "LowWater" ? "LW" : ""));
        const nextLabel = next ? typeLabel(next.EventType) : "";
        const prevLabel = prev ? typeLabel(prev.EventType) : "";

        if (prev && next && next._t !== prev._t) {
          // Determine rising/falling from the bracketed events
          if (prev.EventType === "LowWater" && next.EventType === "HighWater") phase = "Rising";
          else if (prev.EventType === "HighWater" && next.EventType === "LowWater") phase = "Falling";
          else phase = "Unknown";

          minsToNext = Math.round((next._t - t) / 60000);
          minsSincePrev = Math.round((t - prev._t) / 60000);
          segmentMins = Math.round((next._t - prev._t) / 60000);

          // Progress between prev->next (0-100)
          progressPct = Math.max(0, Math.min(100, Math.round((minsSincePrev / segmentMins) * 100)));

          // Human relation: before next tide (e.g. "Before HW") + how far through
          relation = `Before ${nextLabel}`;
          const absH = Math.min(6, Math.max(0, Math.floor(Math.abs(minsToNext)/60)));
          bucket = `${nextLabel} -${absH}h`;
        } else if (next) {
          // Only know the next event
          phase = next.EventType === "HighWater" ? "Rising" : "Falling";
          minsToNext = Math.round((next._t - t) / 60000);
          relation = `Before ${nextLabel}`;
          const absH = Math.min(6, Math.max(0, Math.floor(Math.abs(minsToNext)/60)));
          bucket = `${nextLabel} -${absH}h`;
        } else if (prev) {
          // Only know the previous event
          phase = prev.EventType === "HighWater" ? "Falling" : "Rising";
          minsSincePrev = Math.round((t - prev._t) / 60000);
          relation = `After ${prevLabel}`;
          const absH = Math.min(6, Math.max(0, Math.floor(Math.abs(minsSincePrev)/60)));
          bucket = `${prevLabel} +${absH}h`;
        }

        return {
          phase,                      // Rising/Falling/Unknown
          relation,                   // Before HW / After LW etc.
          progressPct,                // % through the segment (when prev+next known)
          minsToNextEvent: minsToNext,
          minsSincePrevEvent: minsSincePrev,
          segmentMins,

          nextEventType: next ? next.EventType : null,
          prevEventType: prev ? prev.EventType : null,
          nextHeight: (next && typeof next.Height === "number") ? next.Height : null,
          prevHeight: (prev && typeof prev.Height === "number") ? prev.Height : null,

          minsToNearestEvent: minsToNearest,
          bucket,
          height: (typeof nearest.Height === "number") ? nearest.Height : null
        };
      } catch {
        return null;
      }
    }

    
function topN(mapObj, n=2){
      return Object.entries(mapObj).sort((a,b)=>b[1]-a[1]).slice(0,n);
    }

    // ===== My BiteWise Intel range filter =====
    const INTEL_RANGE_KEY = "aos_intel_range_v1";

    function getIntelRangeValue(){
      const sel = document.getElementById('intelRange');
      const saved = localStorage.getItem(INTEL_RANGE_KEY);
      const val = (sel && sel.value) ? sel.value : (saved || "30");
      return val || "30";
    }

    function applySavedIntelRange(){
      const sel = document.getElementById('intelRange');
      if (!sel) return;
      const saved = localStorage.getItem(INTEL_RANGE_KEY);
      if (saved && Array.from(sel.options).some(o => o.value === saved)) {
        sel.value = saved;
      }
    }

    function intelRangeStartMs(){
      const v = getIntelRangeValue();
      if (v === "all") return null;
      const days = Number(v);
      if (!Number.isFinite(days) || days <= 0) return null;
      return Date.now() - (days * 86400000);
    }

    function formatIntelRangeLabel(){
      const v = getIntelRangeValue();
      if (v === "all") return "All-time";
      const days = Number(v);
      if (!Number.isFinite(days)) return "Last 30 days";
      return `Last ${days} days`;
    }

    function renderIntelRangeMeta(){
      const meta = document.getElementById('intelRangeMeta');
      if (!meta) return;
      const v = getIntelRangeValue();
      const start = intelRangeStartMs();
      if (v === "all" || !start){
        meta.innerHTML = `Showing <b>${escapeHtml(formatIntelRangeLabel())}</b>.`;
        return;
      }
      const startStr = new Date(start).toLocaleDateString([], { day:'2-digit', month:'short', year:'numeric' });
      const endStr = new Date().toLocaleDateString([], { day:'2-digit', month:'short', year:'numeric' });
      meta.innerHTML = `Showing <b>${escapeHtml(formatIntelRangeLabel())}</b> (${escapeHtml(startStr)} ‚Äì ${escapeHtml(endStr)}).`;
    }

    function catchTimestampMs(c){
      const ts = c?.caughtAt ?? c?.timestamp ?? c?.createdAt;
      const n = Number(ts);
      return Number.isFinite(n) ? n : null;
    }

    function filterCatchesByIntelRange(list){
      const start = intelRangeStartMs();
      if (!start) return list;
      return list.filter(c => {
        const ts = catchTimestampMs(c);
        return ts ? ts >= start : false;
      });
    }

    function renderMyIntel(){
      const el = document.getElementById('myIntelBody');
      if (!el) return;

      renderIntelRangeMeta();

      const portName = (envData.port || "").trim();
      const portId = envData.id || envData.portId || null;

      if (!portName){
        el.innerHTML = "Select a port to see patterns from your catches.";
        return;
      }

      const pn = (portName || '').trim().toLowerCase();
      const atPortAll = catches.filter(c => {
        const cid = (c.portId || c.idPort || c.stationId || '').toString();
        if (portId && cid && cid === String(portId)) return true;
        const cl = (c.loc || '').trim().toLowerCase();
        return cl && cl === pn;
      });

      const atPort = filterCatchesByIntelRange(atPortAll);
      const total = atPort.length;

      if (total === 0){
        el.innerHTML = `
          <div style="font-weight:900; color:var(--white); margin-bottom:6px;">${escapeHtml(portName)}</div>
          <div class="muted">No catches found for this port in the selected range.</div>
          <div class="muted" style="margin-top:8px;">Based on 0 catches.</div>
        `;
        return;
      }

      const tideBuckets = {};
      const phases = {};
      const moon = {};
      const hours = {};

      // Track how many catches actually contributed to each section
      let tideN = 0;
      let phaseN = 0;
      let moonN = 0;
      let hourN = 0;

      for (const c of atPort){
        // Hour-of-day from timestamp
        const ts = catchTimestampMs(c);
        if (ts){
          const h = new Date(ts).getHours();
          const key = `${String(h).padStart(2,'0')}:00`;
          hours[key] = (hours[key]||0)+1;
          hourN++;
        }

        // Tide context (prefer stored; otherwise try derive; otherwise fall back to saved tide label)
        const tc = c.tideCtx || c.tideContext || tideContextFor(ts || Date.now(), c.portId || portId);
        let tideAdded = false;
        let phaseAdded = false;

        if (tc){
          if (tc.bucket){ tideBuckets[tc.bucket] = (tideBuckets[tc.bucket]||0)+1; tideAdded = true; }
          if (tc.phase){ phases[tc.phase] = (phases[tc.phase]||0)+1; phaseAdded = true; }
        } else {
          const tlabel = (c.tide || "").toString().toLowerCase();
          // Older records may only store a simple label like "7.6m High". Use a coarse bucket so intel isn't blank.
          if (tlabel.includes("high")){ tideBuckets["HW (near)"] = (tideBuckets["HW (near)"]||0)+1; tideAdded = true; }
          if (tlabel.includes("low")){ tideBuckets["LW (near)"] = (tideBuckets["LW (near)"]||0)+1; tideAdded = true; }
          if (tlabel.includes("rising")){ phases["Rising"] = (phases["Rising"]||0)+1; phaseAdded = true; }
          if (tlabel.includes("falling")){ phases["Falling"] = (phases["Falling"]||0)+1; phaseAdded = true; }
        }

        if (tideAdded) tideN++;
        if (phaseAdded) phaseN++;

        // Moon phase (stored, or derive)
        const mp = c.moon || (ts ? moonPhaseInfo(ts) : null);
        if (mp && mp.name){
          moon[mp.name] = (moon[mp.name]||0)+1;
          moonN++;
        }
      }

      const bestTide = topN(tideBuckets, 1)[0];
      const bestPhase = topN(phases, 1)[0];
      const bestMoon = topN(moon, 1)[0];
      const bestHour = topN(hours, 1)[0];

      function fmtStat(pair, label, nUsed){
        if (!pair || !pair[0]) return `<div class="muted">${escapeHtml(label)}: Not enough data yet.</div>`;
        const denom = Math.max(1, nUsed || total);
        const pct = Math.round((pair[1]/denom)*100);
        return `<div><b>${escapeHtml(label)}:</b> <span class="muted">${escapeHtml(pair[0])}</span> <span class="muted">(${pct}%)</span> <span class="muted">‚Ä¢ based on ${nUsed || 0}</span></div>`;
      }

      // If overall sample is small, still show whatever we can, but label the sample clearly.
      const overallNote = total < 3
        ? `<div class="muted" style="margin-top:8px;">Low sample size ‚Äî patterns may be noisy.</div>`
        : "";

      el.innerHTML = `
        <div style="font-weight:900; color:var(--white); margin-bottom:6px;">${escapeHtml(portName)}</div>
        <div style="display:grid; gap:6px;">
          ${fmtStat(bestTide, "Best tide window", tideN)}
          ${fmtStat(bestPhase, "Rising vs falling", phaseN)}
          ${fmtStat(bestHour, "Best time", hourN)}
          ${fmtStat(bestMoon, "Best moon", moonN)}
        </div>
        ${overallNote}
        <div class="muted" style="margin-top:8px;">Based on ${total} catch${total===1?"":"es"} in this range.</div>
      `;
    }
    // ===== Tide snapshot (for saving catches) =====
    function getCurrentTideSnapshot(nowMs) {
      const summaryEl = document.getElementById("hTide");
      const detailEl  = document.getElementById("hTideD") || document.getElementById("tideDetail");
      const summary = (summaryEl?.textContent || "").trim();
      const detail  = (detailEl?.textContent || "").trim();

      // Prefer computed context (uses cached tide events if available)
      let ctx = null;
      try {
        ctx = tideContextFor(nowMs, envData.id || envData.portId || null);
      } catch (e) {}
      // Enrich ctx from HUD if some fields are missing (e.g. cache not ready)
      if (ctx) {
        if (!ctx.phase && detail) ctx.phase = /rising/i.test(detail) ? "Rising" : (/falling/i.test(detail) ? "Falling" : ctx.phase);
        if ((!ctx.relation || ctx.relation==="") && summary) {
          const nt = /high/i.test(summary) ? "HW" : (/low/i.test(summary) ? "LW" : "");
          if (nt) ctx.relation = "Before " + nt;
        }
      }


      // Fallback: parse HUD text if ctx is missing
      if (!ctx && (summary || detail)) {
        const rising = /rising/i.test(detail);
        const falling = /falling/i.test(detail);
        const m1 = detail.match(/in\s+(\d+)\s*h\s*(\d+)\s*m/i);
        const m2 = detail.match(/in\s+(\d+)\s*m/i);
        let minsTo = null;
        if (m1) minsTo = (parseInt(m1[1],10)*60 + parseInt(m1[2],10));
        else if (m2) minsTo = parseInt(m2[1],10);

        // summary often like "6.9m High" / "1.2m Low"
        let heightM = null, nextType = "";
        const ms = summary.match(/([0-9]+(?:\.[0-9]+)?)\s*m/i);
        if (ms) heightM = parseFloat(ms[1]);
        if (/high/i.test(summary)) nextType = "High";
        else if (/low/i.test(summary)) nextType = "Low";

        ctx = {
          source: "hud",
          phase: rising ? "rising" : (falling ? "falling" : ""),
          minsToNext: (minsTo !== null && Number.isFinite(minsTo)) ? minsTo : null,
          nextType,
          nextHeightM: (heightM !== null && Number.isFinite(heightM)) ? heightM : null,
          summary,
          detail
        };
      }

      // Also provide a plain string snapshot for backwards compatibility
      const tideStr = (envData.tide && String(envData.tide).trim()) ? String(envData.tide).trim()
                    : (summary || detail ? [summary, detail].filter(Boolean).join(" ‚Äî ") : "");

      return { tideStr, tideCtx: ctx, tideHud: { summary, detail } };
    }

async function saveCatch() {
      const s = document.getElementById('sp').value.trim();
      if (!s) return notify("Enter Species");

      const now = new Date();
      const dStr = todayStr();
      const tStr = now.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });

      const wt = Number(document.getElementById('wt').value || 0);
      const len = Number(document.getElementById('len').value || 0);
      const notes = document.getElementById('notes').value || "";

      const file = document.getElementById('photo').files?.[0];
      const photo = file ? await fileToCompressedDataUrl(file, 900, 0.72) : "";

      const nowMs = Date.now();
      // Require a selected port/location (so tide/weather/flow/pressure can be captured)
      const portVal = (document.getElementById('portList')?.value || "").toString().trim();
      const hasPortSel = !!portVal;
      const hasEnvPort = !!(envData && (envData.id || envData.portId) && String(envData.port||"").trim());

      if (!hasPortSel || !hasEnvPort) {
        try {
          const msg = "Select a port/favourite (or pick from map) before saving a catch.";
          if (typeof showToast === 'function') showToast(msg);
          else if (typeof toast === 'function') toast(msg);
          else alert(msg);
        } catch(e){}
        try { document.getElementById('portList')?.focus(); } catch(e){}
        return;
      }
      const activeSession = SessionEngine.ensureActive(getSessionMetaFromEnv());
      renderSessionBar();

            const moon = moonPhaseInfo(nowMs);
      const tideSnap = getCurrentTideSnapshot(nowMs);
      const tideCtx = tideSnap.tideCtx;

      const docRef = await addDoc(collection(db, "catches"), {
        userId: auth.currentUser.uid,
        sp: s.toUpperCase(),
        wt,
        len,
        notes,
        photoUrl: "",
        photoPath: "",
        photo: "",
        photoPending: !!photo,
        dt: dStr,
        time: tStr,
        loc: envData.port,
        portId: envData.id || envData.portId || "",
        moon,
        tideCtx,

        press: envData.press || "",
        baro: envData.press || "",
        temp: envData.temp || "",
        weather: envData.weather || "",
        wind: envData.wind || "",
        gust: envData.gust || "",
        tide: tideSnap.tideStr || "",
        tideHud: tideSnap.tideHud || null,
        flow: envData.flow || "",

        sessionId: activeSession.id,
        caughtAt: nowMs,

        createdAt: Date.now(),
        timestamp: Date.now()
      });

      // Upload photo to Firebase Storage (optional) and patch catch record with URL
      if (photo) {
        const uid = auth.currentUser.uid;

        // Mark as pending immediately (Firestore persistence will queue this while offline)
        try { await updateDoc(docRef, { photoPending: true, photoUrl:"", photoPath:"", photo:"" }); } catch(e) {}

        if (navigator.onLine) {
          try {
            const up = await uploadCatchPhotoToStorage(uid, docRef.id, photo);
            if (up) {
              await updateDoc(docRef, { ...up, photo: "", photoPending: false });
            } else {
              enqueueStorageUpload(uid, docRef.id, photo);
            }
          } catch(e) {
            enqueueStorageUpload(uid, docRef.id, photo);
          }
        } else {
          enqueueStorageUpload(uid, docRef.id, photo);
        }
      }

      updateSessionBadge();
      notify("RECORD SAVED");
      renderMyIntel();
      document.getElementById('sp').value = "";
      document.getElementById('wt').value = "";
      document.getElementById('len').value = "";
      document.getElementById('notes').value = "";
      document.getElementById('photo').value = "";
    }

    // ===== Wire UI =====

      // My BiteWise Intel drawer toggle
      document.getElementById('myIntelToggleBtn').onclick = () => {
        const d = document.getElementById('myIntelDrawer');
        const open = d.style.display === 'block';
        d.style.display = open ? 'none' : 'block';
        document.getElementById('myIntelToggleBtn').textContent = open ? 'üß† My BiteWise Intel' : 'üß† My BiteWise Intel (Hide)';
      };

      // Catch Explorer toggle
      document.getElementById('explorerToggleBtn').onclick = () => {
        const b = document.getElementById('explorerBody');
        const open = b.style.display === 'block';
        b.style.display = open ? 'none' : 'block';
        document.getElementById('explorerToggleBtn').textContent = open ? 'Show' : 'Hide';
        if (!open) runExplorer(); // refresh when opened
      };

      function _timeBucket(ms){
        const h = new Date(ms).getHours();
        if (h >= 4 && h < 8) return 'dawn';
        if (h >= 18 && h < 22) return 'dusk';
        if (h >= 22 || h < 4) return 'night';
        return 'day';
      }
      function _tideStageFromPct(p){
        const n = Number(p);
        if (!Number.isFinite(n)) return null;
        if (n < 33) return 'early';
        if (n < 67) return 'mid';
        return 'late';
      }
      function _parseWindFromCatch(c){
        const raw = ((c && (c.wind || c.windTxt || c.windText)) ? (c.wind || c.windTxt || c.windText) : '') + (c && c.gust ? (' ' + c.gust) : '');
        const s = (raw || '').toString().trim().toUpperCase();
        if (!s) return {dir16:null, dir8:null, speed:null};

        // Direction token anywhere (no strict word-boundary to handle 'ENE,' etc.)
        const dirMatch = s.match(/(NNE|ENE|ESE|SSE|SSW|WSW|WNW|NNW|NE|SE|SW|NW|N|E|S|W)/);
        const dir16 = dirMatch ? dirMatch[1] : null;

        // Map to 8-point for broad matching (ENE -> E, NNE -> NE, etc.)
        const map8 = {
          N:'N', NNE:'NE', NE:'NE', ENE:'E', E:'E', ESE:'E', SE:'SE', SSE:'S',
          S:'S', SSW:'SW', SW:'SW', WSW:'W', W:'W', WNW:'W', NW:'NW', NNW:'N'
        };
        const dir8 = dir16 ? (map8[dir16] || dir16) : null;

        // Speed parsing: mph or knots (convert knots->mph)
        let speed = null;
        const mph = s.match(/(\d+(?:\.\d+)?)\s*MPH/i);
        if (mph) speed = Number(mph[1]);
        if (!mph) {
          const kn = s.match(/(\d+(?:\.\d+)?)\s*(KN|KTS)\b/i);
          if (kn) {
            const k = Number(kn[1]);
            if (Number.isFinite(k)) speed = k * 1.15078;
          }
        }
        return {dir16, dir8, speed: Number.isFinite(speed) ? speed : null};
      }

      function _withinRange(ms, rangeVal){
        if (rangeVal === 'all') return true;
        const days = Number(rangeVal);
        if (!Number.isFinite(days)) return true;
        return ms >= (Date.now() - days*86400000);
      }

      function _getCatchMs(c){
        const v = c?.caughtAt ?? c?.timestamp ?? c?.createdAt ?? c?.ts ?? c?.when ?? c?.dateTime ?? null;
        if (v === null || v === undefined) return null;

        // Firestore Timestamp support
        try {
          if (typeof v?.toMillis === 'function') {
            const ms = v.toMillis();
            return Number.isFinite(ms) ? ms : null;
          }
          if (typeof v === 'object' && (v.seconds !== undefined || v._seconds !== undefined)) {
            const sec = (v.seconds !== undefined) ? v.seconds : v._seconds;
            const ms = Number(sec) * 1000;
            return Number.isFinite(ms) ? ms : null;
          }
        } catch(e){}

        if (typeof v === 'number') return Number.isFinite(v) ? v : null;

        if (typeof v === 'string') {
          const s = v.trim();
          if (!s) return null;
          // numeric string
          const n = Number(s);
          if (Number.isFinite(n) && s.length >= 10) return n;
          const p = Date.parse(s);
          return Number.isFinite(p) ? p : null;
        }

        return null;
      }


      
      function _fmtCond(c){
        const parts = [];
        if (c.time) parts.push(c.time);
        if (c.wind) parts.push(c.wind);
        if (c.tide) parts.push(c.tide);
        return parts.filter(Boolean).join(" ‚Ä¢ ");
      }

      function computeBestConditions(allRows, scopePortId, scopePortName){
        // Group by condition set. Score by avg weight primarily, then count.
        const groups = new Map();

        function keyFor(c){
          const ms = _getCatchMs(c);
          const time = _timeBucket(ms);
          const w = _parseWindFromCatch(c);
          const wind = w.dir16 || w.dir8 || null;
          const phase = (c.tideCtx?.phase || "").toString().toLowerCase();
          const stage = _tideStageFromPct(c.tideCtx?.progressPct);
          const tide = (phase ? (phase === "rising" ? "flood" : (phase === "falling" ? "ebb" : phase)) : null) + (stage ? (" " + stage) : "");
          return [time||"", wind||"", tide||""].join("|");
        }

        for (const c of allRows){
          // port scope already applied before calling
          const k = keyFor(c);
          if (!groups.has(k)) groups.set(k, {n:0, w:0, sp:{}, example:c});
          const g = groups.get(k);
          g.n += 1;
          g.w += (Number(c.wt)||0);
          const sp = ((c.sp||"")+"").trim().toUpperCase() || "UNKNOWN";
          g.sp[sp] = (g.sp[sp]||0)+1;
        }

        const arr = [];
        for (const [k,g] of groups.entries()){
          if (g.n < 2) continue; // avoid singletons
          const [time, wind, tide] = k.split("|");
          const avg = g.w / g.n;
          const topSp = Object.entries(g.sp).sort((a,b)=>b[1]-a[1])[0];
          arr.push({
            time: time || null,
            wind: wind || null,
            tide: tide || null,
            n: g.n,
            totalW: g.w,
            avgW: avg,
            topSp: topSp ? `${topSp[0]} x${topSp[1]}` : ""
          });
        }

        // Sort by avg weight then count then total weight
        arr.sort((a,b)=> (b.avgW - a.avgW) || (b.n - a.n) || (b.totalW - a.totalW));
        return arr.slice(0, 8);
      }

function runExplorer(){
        const expRange = document.getElementById('expRange').value;
        const expPort = document.getElementById('expPort').value;
        const phase = document.getElementById('expTidePhase').value;
        const stage = document.getElementById('expTideStage').value;
        const wdir = document.getElementById('expWindDir').value;
        const wminRaw = document.getElementById('expWindMin').value.trim();
        const wmin = (wminRaw === '') ? null : Number(wminRaw);
        const wmaxRaw = document.getElementById('expWindMax').value.trim();
        const wmax = (wmaxRaw === '') ? null : Number(wmaxRaw);
        const timeB = document.getElementById('expTime').value;

        const reject = {ms:0, range:0, port:0, phaseMissing:0, phaseMismatch:0, stage:0, windDir:0, windMin:0, windMax:0, time:0};

        const selectedPortId = (envData?.id || envData?.portId || '').toString();
        const selectedPortName = (envData?.port || '').toString().trim().toLowerCase();
        const all = (Array.isArray(catches) ? catches : []);
        let parsedMsCount = 0;
        let parsedWindCount = 0;
        const rows = [];
        for (const c of all) {
          const ms = _getCatchMs(c);
          if (ms !== null) parsedMsCount++;
          if (!Number.isFinite(ms)) { reject.ms++; continue; }
          if (!_withinRange(ms, expRange)) { reject.range++; continue; }

          if (expPort === 'selected') {
            const cid = (c.portId || c.idPort || c.stationId || '').toString();
            const cl = (c.loc || '').toString().trim().toLowerCase();
            if (selectedPortId && cid && cid === selectedPortId) {}
            else if (selectedPortName && cl === selectedPortName) {}
            else { reject.port++; continue; }
          }

          const ph = (c.tideCtx?.phase || '').toString().toLowerCase();
          if (phase !== 'any') {
            if (!ph) { reject.phaseMissing++; continue; }
            if (ph !== phase) { reject.phaseMismatch++; continue; }
          }

          const st = _tideStageFromPct(c.tideCtx?.progressPct);
          if (stage !== 'any' && st !== stage) { reject.stage++; continue; }

          const w = _parseWindFromCatch(c);
          if (w && (w.dir16 || w.dir8 || w.speed !== null)) parsedWindCount++;

          if (wdir !== 'any') {
            const want = wdir.toUpperCase();
            const rawWind = ((c.wind||'') + ' ' + (c.gust||'')).toUpperCase();
            const ok = (w.dir16 === want) || (w.dir8 === want) || rawWind.includes(want);
            if (!ok) { reject.windDir++; continue; }
          }

          if (wmin !== null && Number.isFinite(wmin) && (w.speed === null || w.speed < wmin)) { reject.windMin++; continue; }
          if (wmax !== null && Number.isFinite(wmax) && (w.speed === null || w.speed > wmax)) { reject.windMax++; continue; }

          const tb = _timeBucket(ms);
          if (timeB !== 'any' && tb !== timeB) { reject.time++; continue; }

          rows.push(c);
        }


        // Summary
        const total = rows.length;
        const totalW = rows.reduce((s,c)=>s+(Number(c.wt)||0),0);
        const avgW = total ? (totalW/total) : 0;

        
        // Best conditions insight: based on RANGE + PORT SCOPE only (ignores specific filters)
        const scopeRows = (Array.isArray(catches) ? catches : []).filter(c => {
          const ms = _getCatchMs(c);
          if (!Number.isFinite(ms)) return false;
          if (!_withinRange(ms, expRange)) return false;
          if (expPort === 'selected') {
            const cid = (c.portId || c.idPort || c.stationId || '').toString();
            const cl = (c.loc || '').toString().trim().toLowerCase();
            if (selectedPortId && cid && cid === selectedPortId) return true;
            if (selectedPortName && cl === selectedPortName) return true;
            return false;
          }
          return true;
        });
        const best = computeBestConditions(scopeRows, selectedPortId, selectedPortName);
        const bestEl = document.getElementById('expBestConditions');
        if (bestEl) {
          bestEl.innerHTML = best.length ? best.map(b => {
            const cond = _fmtCond(b);
            return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);">
                      <div style="max-width:70%;">
                        <b>${escapeHtml(cond || "‚Äî")}</b>
                        <div class="muted" style="font-size:.82rem; margin-top:2px;">${escapeHtml(b.topSp || "")}</div>
                      </div>
                      <div style="text-align:right;">
                        <div>${b.n} catch${b.n===1?'':'es'}</div>
                        <div class="muted" style="font-size:.82rem;">avg ${b.avgW.toFixed(1)}lb</div>
                      </div>
                    </div>`;
          }).join('') : `<div class="muted">Not enough repeat data yet (need 2+ catches per condition set).</div>`;
        }

document.getElementById('expSummary').textContent =
          total ? `${total} catch${total===1?'':'es'} match ‚Ä¢ Total ${totalW.toFixed(1)} lb ‚Ä¢ Avg ${avgW.toFixed(1)} lb`
                : 'No catches match these filters.';

        // Top ports
        const byPort = {};
        for (const c of rows){
          const name = (c.loc || 'Unknown').toString();
          if (!byPort[name]) byPort[name] = {n:0, w:0, sp:{}};
          byPort[name].n += 1;
          const sp = ((c.sp||'')+'').trim().toUpperCase() || 'UNKNOWN';
          byPort[name].sp[sp] = (byPort[name].sp[sp]||0) + 1;
          byPort[name].w += (Number(c.wt)||0);
        }
        const ports = Object.entries(byPort).sort((a,b)=> (b[1].n - a[1].n) || (b[1].w - a[1].w)).slice(0,7);
        document.getElementById('expTopPorts').innerHTML = ports.length
          ? ports.map(([k,v])=>{const topSp = Object.entries(v.sp||{}).sort((a,b)=>b[1]-a[1])[0]; const spTxt = topSp ? `${topSp[0]} x${topSp[1]}` : ''; return `<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);"><div><b>${escapeHtml(k)}</b><div class='muted' style='font-size:.82rem; margin-top:2px;'>${escapeHtml(spTxt)}</div></div><div>${v.n} ‚Ä¢ ${v.w.toFixed(1)}lb</div></div>`}).join('')
          : `<div class="muted">‚Äî</div>`;

        // Top times
        const byTime = {};
        for (const c of rows){
          const ms = _getCatchMs(c);
          if (ms !== null) parsedMsCount++;
          const tb = _timeBucket(ms);
          byTime[tb] = (byTime[tb] || 0) + 1;
        }
        const times = Object.entries(byTime).sort((a,b)=>b[1]-a[1]);
        
        // Top species (overall)
        const bySp = {};
        for (const c of rows){
          const sp = ((c.sp||'')+'').trim().toUpperCase() || 'UNKNOWN';
          bySp[sp] = (bySp[sp] || 0) + 1;
        }
        const sps = Object.entries(bySp).sort((a,b)=>b[1]-a[1]).slice(0,10);
        const spEl = document.getElementById('expTopSpecies');
        if (spEl) {
          spEl.innerHTML = sps.length
            ? sps.map(([k,n])=>`<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);"><div><b>${escapeHtml(k)}</b></div><div>${n}</div></div>`).join('')
            : `<div class="muted">‚Äî</div>`;
        }

document.getElementById('expTopTimes').innerHTML = times.length
          ? times.map(([k,n])=>`<div style="display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06);"><div><b>${k}</b></div><div>${n}</div></div>`).join('')
          : `<div class="muted">‚Äî</div>`;
      }

      document.getElementById('expApplyBtn').onclick = runExplorer;
    function wireUI() {
      document.getElementById('loginBtn').onclick = async () => {
        try {
          await signInWithEmailAndPassword(
            auth,
            document.getElementById('loginEmail').value,
            document.getElementById('loginPass').value
          );
        } catch (e) {
          console.error(e);
          notify("Login Error");
        }
      };

      document.getElementById('createAccountBtn').onclick = async () => {
        const email = document.getElementById('loginEmail').value.trim();
        const pass  = document.getElementById('loginPass').value;
        if (!email || !pass || pass.length < 6) {
          notify("Enter email + password (6+ chars)");
          return;
        }
        try {
          await createUserWithEmailAndPassword(auth, email, pass);
          notify("Account created ‚úÖ");
        } catch (e) {
          console.error(e);
          // Common case: account already exists
          notify(e?.message || "Sign up error");
        }
      };

      document.getElementById('forgotPassBtn').onclick = async () => {
        const email = document.getElementById('loginEmail').value.trim();
        if (!email) {
          notify("Enter your email first");
          return;
        }
        try {
          await sendPasswordResetEmail(auth, email);
          notify("Reset email sent ‚úÖ");
        } catch (e) {
          console.error(e);
          notify(e?.message || "Reset error");
        }
      };


      document.getElementById('logoutBtn').onclick = async () => {
        if (unsubCatches) { try { unsubCatches(); } catch(e) {} unsubCatches = null; }
        // clear local in-memory state to avoid UI trying to render protected data
        catches = [];
        renderCalendar();
        renderDiary();
        renderMyIntel();
        await signOut(auth);
      };


      // Intel range selector
      applySavedIntelRange();
      renderIntelRangeMeta();
      const intelSel = document.getElementById('intelRange');
      if (intelSel) {
        intelSel.onchange = () => {
          localStorage.setItem(INTEL_RANGE_KEY, intelSel.value);
          renderMyIntel();
        };
      }

      document.getElementById('portList').onchange = (e) => {
        const val = e.target.value;
        if (val) handlePort(val);
      };

      // If the user clicks an already-highlighted option, 'change' may not fire.
      // Apply selection on click as well.
      document.getElementById('portList').onclick = (e) => {
        const val = e.target.value;
        if (val) handlePort(val);
      };

      document.getElementById('gpsSyncBtn').onclick = () => {
        navigator.geolocation.getCurrentPosition(
          pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            const acc = pos.coords.accuracy; // meters

            const ACC_LIMIT = 5000; // 5km guardrail
            if (!acc || acc > ACC_LIMIT) {
              notify(`‚ö†Ô∏è GPS accuracy too low (¬±${Math.round(acc || 0)}m). Not selecting a port.`);
              console.warn("Low-accuracy GPS:", { lat, lon, acc });
              return;
            }

            const n = nearestPort(lat, lon);
            if (!n) return notify("Ports not loaded yet");

            resetPortSearchUI();
            document.getElementById('portList').value = String(n.id);
            handlePort(n.id);

            const km = (n._distMeters / 1000).toFixed(1);
            notify(`üìç GPS: ${n.name.toUpperCase()} (${km}km away, ¬±${Math.round(acc)}m)`);
          },
          err => {
            console.warn("Geolocation error:", err);
            notify("GPS Denied");
          },
          { enableHighAccuracy: true, timeout: 20000, maximumAge: 60000 }
        );
      };

      document.getElementById('addFavBtn').onclick = async () => {
        // If the user typed in the search box but didn‚Äôt explicitly confirm a selection,
        // the dropdown may already have the right value while envData.id is still empty.
        if (!envData.id) {
          const v = document.getElementById('portList')?.value;
          if (v) {
            try { await handlePort(String(v)); } catch {}
          }
        }
        if (!envData.id) return;

        const exists = favs.some(f => String(f.id) === String(envData.id));
        if (exists) {
          notify(`"${envData.port}" is already a favourite`);
          setFavButtonState();
          return;
        }

        favs.push({ id: String(envData.id), name: envData.port });
        localStorage.setItem('aos_favs', JSON.stringify(favs));
        updateFavsUI();
        setFavButtonState();
        notify(`Added "${envData.port}" to favourites`);
      };

      document.getElementById('saveBtn').onclick = saveCatch;

      document.getElementById('totalsBtn').onclick = () => {
        const box = document.getElementById('totalsBox');
        if (box.style.display === 'block') {
          box.style.display = 'none';
        } else {
          document.getElementById('totalsSummary').innerHTML = buildSessionSummaryHtml();
          box.style.display = 'block';
        }
      };


      document.getElementById('sessionStartBtn').onclick = () => {
        const s = SessionEngine.start(getSessionMetaFromEnv());
        updateSessionBadge();
        renderSessionBar();
        notify("Session started");
      };

      document.getElementById('sessionEndBtn').onclick = () => {
        const s = SessionEngine.getActive();
        if (!s) return notify("No active session");
        SessionEngine.end(s.id);
        updateSessionBadge();
        renderSessionBar();
        notify("Session ended");
      };

      document.getElementById('helpBtn').onclick = () => showHelp();
document.getElementById('aboutBtn').onclick = () => {
        const year = new Date().getFullYear();
        openModal("About BiteWise", `
          <div style="font-size:0.9rem; line-height:1.6;">
            <div><b>BiteWise</b> v13.10.7</div>
            <div class="muted">¬© ${year} BiteWise. All rights reserved.</div>
            <div class="muted" style="margin-top:10px;">
              Prototype build for testing (photos stored in Firebase Storage; thumbnails may be compressed).
            </div>
          </div>
        `);
      };
    }

    // ===== App init =====
    async function initApp(uid) {
      currentUid = uid;

      // Offline-safe Storage ops: bind online handler + attempt to flush any queued uploads/deletes
      bindStorageOpsOnlineHandler();
      processStorageOpsOnce();


      initMapOnce();
      await loadPorts();
      updateFavsUI();
      setFavButtonState();
      renderSessionBar();
      showQuickStartOnce();

      const qy = query(
        collection(db, "catches"),
        where("userId", "==", uid),
        orderBy("timestamp", "desc")
      );

      if (unsubCatches) { try { unsubCatches(); } catch(e) {} unsubCatches = null; }
      unsubCatches = onSnapshot(
        qy,
        (snap) => {
          catches = snap.docs.map(d => ({ id: d.id, ...d.data() }));
          updateSessionBadge();
          renderSessionBar();

          const box = document.getElementById('totalsBox');
          if (box.style.display === 'block') {
            document.getElementById('totalsSummary').innerHTML = buildSessionSummaryHtml();
          }

          // Default history view: today (unless user manually selected another date)
          if (!userSelectedDate) {
            selectedDate = todayStr();
          }

          renderCalendar();
          renderDiary();
          renderMyIntel();
},
        (err) => {
          if (!auth.currentUser) return;
          console.error("Firestore listener error:", err);
          if (err?.code === "permission-denied") notify("Firestore blocked by rules (permission denied).");
          else notify("Firestore error: " + (err?.code || "unknown"));
        }
      );
    }

    document.addEventListener('DOMContentLoaded', () => {
      wireUI();

      // Tick session duration label
      setInterval(() => { try { renderSessionBar(); } catch {} }, 30000);

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          document.getElementById('authScreen').style.display = 'none';
          document.getElementById('mainApp').style.display = 'block';
          if (!currentUid) await initApp(user.uid);
        } else {
          currentUid = null;
          if (unsubCatches) { try { unsubCatches(); } catch(e) {} unsubCatches = null; }
          document.getElementById('authScreen').style.display = 'flex';
          document.getElementById('mainApp').style.display = 'none';
        }
      });
    });
  </script>

<script>
/* ===== SOLUNAR / BITE WINDOW (OFFLINE, LOCATION-AWARE) =====
   Minor: Moonrise / Moonset (¬±45m)
   Major: Upper / Lower transit (¬±60m)
   Notes:
   - Uses low/medium precision lunar position + standard rise/set scanning (SunCalc-style).
   - Works offline; no external APIs.
=========================================================== */
(function () {
  const rad = Math.PI / 180;
  const dayMs = 86400000;
  const minMs = 60000;

  function toJulian(date) { return date.valueOf() / dayMs - 0.5 + 2440588; }
  function fromJulian(j) { return new Date((j + 0.5 - 2440588) * dayMs); }
  function toDays(date) { return toJulian(date) - 2451545; }

  function rightAscension(l, b) {
    const e = rad * 23.4397;
    return Math.atan2(Math.sin(l) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(l));
  }
  function declination(l, b) {
    const e = rad * 23.4397;
    return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(l));
  }
  function siderealTime(d, lw) { return rad * (280.16 + 360.9856235 * d) - lw; }

  // Low/medium precision Moon coordinates (good enough for solunar windows).
  function moonCoords(d) {
    const L = rad * (218.316 + 13.176396 * d);
    const M = rad * (134.963 + 13.064993 * d);
    const F = rad * (93.272 + 13.229350 * d);

    const l = L + rad * 6.289 * Math.sin(M);   // longitude
    const b = rad * 5.128 * Math.sin(F);       // latitude

    return { ra: rightAscension(l, b), dec: declination(l, b) };
  }

  function altitude(H, phi, dec) {
    return Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));
  }

  function getMoonPosition(date, lat, lon) {
    const lw = rad * -lon;
    const phi = rad * lat;
    const d = toDays(date);
    const c = moonCoords(d);

    const H = siderealTime(d, lw) - c.ra;
    const h = altitude(H, phi, c.dec);

    // simple refraction correction
    const hCorr = h + rad * 0.017 / Math.tan(h + rad * 10.26 / (h + rad * 5.10));
    return { altitude: hCorr, hourAngle: H, dec: c.dec };
  }

  // Quadratic interpolation helpers (SunCalc-style)
  function quadraticRoot(x0, x1, x2) {
    const a = (x0 + x2) / 2 - x1;
    const b = (x2 - x0) / 2;
    const c = x1;
    const disc = b * b - 4 * a * c;
    if (disc < 0) return null;
    const dx = Math.sqrt(disc) / (Math.abs(2 * a) || 1e-12);
    const r1 = -b / (2 * a) - dx;
    const r2 = -b / (2 * a) + dx;
    return [r1, r2].filter(r => r >= -1 && r <= 1);
  }

  function getMoonRiseSet(date, lat, lon) {
    // scan in 2-hour steps (local time) to find rise/set crossings.
    // h0: apparent moon radius + refraction (~0.133¬∞) below horizon.
    const h0 = rad * 0.133;

    const t0 = new Date(date); t0.setHours(0,0,0,0);
    let hc = getMoonPosition(t0, lat, lon).altitude - h0;

    let rise = null, set = null;

    for (let i = 1; i <= 24; i += 2) {
      const t1 = new Date(t0.getTime() + i * 3600000);
      const t2 = new Date(t0.getTime() + (i + 1) * 3600000);
      const t3 = new Date(t0.getTime() + (i + 2) * 3600000);

      const h1 = getMoonPosition(t1, lat, lon).altitude - h0;
      const h2 = getMoonPosition(t2, lat, lon).altitude - h0;
      const h3 = getMoonPosition(t3, lat, lon).altitude - h0;

      // fit parabola through (0,h1) (1,h2) (2,h3) by shifting to x=-1,0,1
      const a = (h1 + h3) / 2 - h2;
      const b = (h3 - h1) / 2;
      const c = h2;

      const roots = quadraticRoot(h1, h2, h3);
      if (roots && roots.length) {
        for (const rt of roots) {
          // rt is in [-1,1] for the centered parabola; map to hours offset from t2 (middle)
          const time = new Date(t2.getTime() + rt * 3600000);
          // determine rising/setting by slope sign
          const deriv = 2 * a * rt + b;
          if (deriv > 0 && !rise) rise = time;
          if (deriv < 0 && !set) set = time;
        }
      }

      if (rise && set) break;
      hc = h3;
    }

    return { rise, set };
  }

  function getMoonTransits(date, lat, lon) {
    // approximate upper/lower transit by scanning altitude over the day and finding max/min
    const t0 = new Date(date); t0.setHours(0,0,0,0);
    const stepMin = 10;
    const steps = Math.round(24 * 60 / stepMin);

    let maxAlt = -1e9, minAlt = 1e9;
    let tMax = null, tMin = null;

    for (let i = 0; i <= steps; i++) {
      const t = new Date(t0.getTime() + i * stepMin * minMs);
      const alt = getMoonPosition(t, lat, lon).altitude;
      if (alt > maxAlt) { maxAlt = alt; tMax = t; }
      if (alt < minAlt) { minAlt = alt; tMin = t; }
    }

    // refine by local search around the best points (¬±30 min, 1-min steps)
    function refine(center) {
      if (!center) return center;
      let bestT = center;
      let bestAlt = getMoonPosition(center, lat, lon).altitude;
      const cMs = center.getTime();
      for (let j = -30; j <= 30; j++) {
        const t = new Date(cMs + j * minMs);
        const alt = getMoonPosition(t, lat, lon).altitude;
        if (alt > bestAlt) { bestAlt = alt; bestT = t; }
      }
      return bestT;
    }
    function refineMin(center) {
      if (!center) return center;
      let bestT = center;
      let bestAlt = getMoonPosition(center, lat, lon).altitude;
      const cMs = center.getTime();
      for (let j = -30; j <= 30; j++) {
        const t = new Date(cMs + j * minMs);
        const alt = getMoonPosition(t, lat, lon).altitude;
        if (alt < bestAlt) { bestAlt = alt; bestT = t; }
      }
      return bestT;
    }

    return { upper: refine(tMax), lower: refineMin(tMin) };
  }

  function buildWindowsForDate(date, lat, lon) {
    const t0 = new Date(date); t0.setHours(0,0,0,0);

    const rs = getMoonRiseSet(t0, lat, lon);
    const tr = getMoonTransits(t0, lat, lon);

    const windows = [];

    // Minor windows: ¬±45 min around rise/set (if available)
    const minorHalf = 45 * minMs;
    if (rs.rise) windows.push({ type: "Minor", start: new Date(rs.rise.getTime() - minorHalf), end: new Date(rs.rise.getTime() + minorHalf), kind: "rise" });
    if (rs.set)  windows.push({ type: "Minor", start: new Date(rs.set.getTime()  - minorHalf), end: new Date(rs.set.getTime()  + minorHalf), kind: "set" });

    // Major windows: ¬±60 min around upper/lower transit
    const majorHalf = 60 * minMs;
    if (tr.upper) windows.push({ type: "Major", start: new Date(tr.upper.getTime() - majorHalf), end: new Date(tr.upper.getTime() + majorHalf), kind: "upper" });
    if (tr.lower) windows.push({ type: "Major", start: new Date(tr.lower.getTime() - majorHalf), end: new Date(tr.lower.getTime() + majorHalf), kind: "lower" });

    windows.sort((a,b) => a.start - b.start);
    return windows;
  }

  function fmtHM(d) {
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function parseMinutesFromTideSub(text) {
    // expects patterns like "Rising ‚Äî in 4h 14m" or "Falling ‚Äî in 55m"
    if (!text) return null;
    const m = text.match(/in\s+(\d+)\s*h\s*(\d+)\s*m/i);
    if (m) return (parseInt(m[1],10)*60 + parseInt(m[2],10));
    const m2 = text.match(/in\s+(\d+)\s*m/i);
    if (m2) return parseInt(m2[1],10);
    return null;
  }

  function getStackSignals() {
    // Tide turning soon: within 90 minutes of next high/low
    const tideTxt = (document.getElementById("hTideD")?.textContent || "").trim();
    const minsToTurn = parseMinutesFromTideSub(tideTxt);
    const tideTurn = (minsToTurn !== null && minsToTurn <= 90);

    // Flow "Feeding zone"
    const flowTxt = (document.getElementById("hFlowD")?.textContent || "").toLowerCase();
    const flowFeed = flowTxt.includes("feeding");

    // Pressure stable or rising
    const pressTxt = (document.getElementById("hPressD")?.textContent || "").toLowerCase();
    const pressOk = pressTxt.includes("stable") || pressTxt.includes("rising");

    const tags = [];
    if (tideTurn) tags.push("Tide turn");
    if (flowFeed) tags.push("Flow");
    if (pressOk) tags.push("Pressure");

    return { tideTurn, flowFeed, pressOk, tags };
  }

  function chooseNextWindow(now, windowsToday, windowsTomorrow) {
    const all = [...windowsToday, ...windowsTomorrow];
    // Determine if currently active
    for (const w of all) {
      if (now >= w.start && now <= w.end) return { ...w, state: "active" };
    }
    // Otherwise find next start
    const upcoming = all.filter(w => w.start > now).sort((a,b)=>a.start-b.start)[0];
    if (!upcoming) return null;
    return { ...upcoming, state: "upcoming" };
  }

  
/* ===== SOLUNAR (offline) =====
   Minor windows: moonrise & moonset (approx)
   Major windows: upper & lower transit (approx via altitude max/min sampling)
   Based on simplified astronomical formulas (similar in spirit to SunCalc approach).
*/
(function(){
  const rad = Math.PI / 180;
  const dayMs = 86400000;
  const J1970 = 2440588;
  const J2000 = 2451545;

  function toJulian(date){ return date.valueOf() / dayMs - 0.5 + J1970; }
  function fromJulian(j){ return new Date((j + 0.5 - J1970) * dayMs); }
  function toDays(date){ return toJulian(date) - J2000; }

  function rightAscension(l, b){
    const e = rad * 23.4397;
    return Math.atan2(Math.sin(l) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(l));
  }
  function declination(l, b){
    const e = rad * 23.4397;
    return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(l));
  }
  function azimuth(H, phi, dec){
    return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(dec) * Math.cos(phi));
  }
  function altitude(H, phi, dec){
    return Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));
  }
  function siderealTime(d, lw){ return rad * (280.16 + 360.9856235 * d) - lw; }

  function moonCoords(d){
    // Geocentric ecliptic coordinates of the Moon
    const L = rad * (218.316 + 13.176396 * d);
    const M = rad * (134.963 + 13.064993 * d);
    const F = rad * (93.272  + 13.229350 * d);

    const l = L + rad * 6.289 * Math.sin(M);          // longitude
    const b = rad * 5.128 * Math.sin(F);              // latitude
    const dt = 385001 - 20905 * Math.cos(M);          // distance to moon in km (not used)
    return { ra: rightAscension(l, b), dec: declination(l, b), dist: dt };
  }

  function moonAltitude(date, lat, lon){
    const lw = rad * -lon;
    const phi = rad * lat;
    const d = toDays(date);
    const c = moonCoords(d);
    const H = siderealTime(d, lw) - c.ra;
    return altitude(H, phi, c.dec);
  }

  function getMoonTimes(date, lat, lon){
    // returns approximate moonrise and moonset for the given date (local time of browser)
    // sample every hour and use quadratic interpolation as in SunCalc.
    const t = new Date(date);
    t.setHours(0,0,0,0);

    const hc = rad * 0.133; // moon apparent radius + refraction (~0.133 deg)

    let rise = null, set = null;
    let prev = moonAltitude(t, lat, lon) - hc;
    for (let i=1; i<=24; i++){
      const ti = new Date(t.getTime() + i*60*60*1000);
      const cur = moonAltitude(ti, lat, lon) - hc;

      // crossing between prev and cur
      if (prev <= 0 && cur > 0 && !rise){
        // refine in this hour
        rise = refineCrossing(new Date(ti.getTime() - 60*60*1000), lat, lon, hc, true);
      }
      if (prev >= 0 && cur < 0 && !set){
        set = refineCrossing(new Date(ti.getTime() - 60*60*1000), lat, lon, hc, false);
      }
      prev = cur;
    }
    return { rise, set };
  }

  function refineCrossing(startHour, lat, lon, hc, wantRise){
    // binary search within the hour for altitude-hc crossing
    let a = new Date(startHour);
    let b = new Date(startHour.getTime() + 60*60*1000);
    let fa = moonAltitude(a, lat, lon) - hc;
    let fb = moonAltitude(b, lat, lon) - hc;
    // ensure bracket; if not, return midpoint
    for (let k=0; k<18; k++){
      const mid = new Date((a.getTime()+b.getTime())/2);
      const fm = moonAltitude(mid, lat, lon) - hc;
      if ((fa <= 0 && fm > 0) || (fa >= 0 && fm < 0)){
        b = mid; fb = fm;
      } else {
        a = mid; fa = fm;
      }
    }
    return new Date((a.getTime()+b.getTime())/2);
  }

  function getTransits(date, lat, lon){
    // approximate upper (max altitude) and lower (min altitude) transit by sampling
    const base = new Date(date);
    base.setHours(0,0,0,0);

    const stepMin = 10; // 10-minute sampling
    const steps = Math.floor(24*60/stepMin);
    let maxA = -1e9, minA = 1e9;
    let tMax = base, tMin = base;

    for (let i=0;i<=steps;i++){
      const ti = new Date(base.getTime() + i*stepMin*60000);
      const alt = moonAltitude(ti, lat, lon);
      if (alt > maxA){ maxA = alt; tMax = ti; }
      if (alt < minA){ minA = alt; tMin = ti; }
    }
    // refine around max/min ¬±30 minutes
    tMax = refineExtremum(tMax, lat, lon, true);
    tMin = refineExtremum(tMin, lat, lon, false);
    return { upper: tMax, lower: tMin };
  }

  function refineExtremum(guess, lat, lon, wantMax){
    // golden-section-ish search in 1-hour window around guess
    let a = new Date(guess.getTime() - 30*60000);
    let b = new Date(guess.getTime() + 30*60000);
    for (let k=0;k<16;k++){
      const t1 = new Date(a.getTime() + (b.getTime()-a.getTime())*0.382);
      const t2 = new Date(a.getTime() + (b.getTime()-a.getTime())*0.618);
      const f1 = moonAltitude(t1, lat, lon);
      const f2 = moonAltitude(t2, lat, lon);
      if (wantMax ? (f1 < f2) : (f1 > f2)){
        a = t1;
      } else {
        b = t2;
      }
    }
    return new Date((a.getTime()+b.getTime())/2);
  }

  // Expose main function
  window.getSolunarWindows = function(date, lat, lon){
    try{
      const d = new Date(date);
      const mt = getMoonTimes(d, lat, lon);
      const tr = getTransits(d, lat, lon);

      const major1 = tr.upper;
      const major2 = tr.lower;
      const minor1 = mt.rise;
      const minor2 = mt.set;

      function w(start, mins){ return {start: start ? new Date(start) : null, end: start ? new Date(start.getTime() + mins*60000) : null}; }

      const maj1 = w(major1, 120);
      const maj2 = w(major2, 120);
      const min1 = w(minor1, 60);
      const min2 = w(minor2, 60);

      return {
        majorStart1: maj1.start, majorEnd1: maj1.end,
        majorStart2: maj2.start, majorEnd2: maj2.end,
        minorStart1: min1.start, minorEnd1: min1.end,
        minorStart2: min2.start, minorEnd2: min2.end,
      };
    } catch(e){
      console.warn("Solunar calc failed", e);
      return null;
    }
  };
})();

function updateBiteCard() {
  const primary = document.getElementById("hBite") || document.getElementById("bitePrimary");
  const secondary = document.getElementById("hBiteD") || document.getElementById("biteSecondary");
  const biteTile = document.getElementById("hudBite");

  if (!primary || !secondary) return;

  // Reset emphasis
  if (biteTile) {
    biteTile.classList.remove("is-active");
    biteTile.classList.remove("is-hot");
  }

  // Location resolution (supports port dropdown, favourites, GPS, map)
  const latCandidates = [window.currentLat, window.envData?.lat, (typeof envData !== 'undefined' ? envData.lat : undefined)];
  const lonCandidates = [window.currentLon, window.envData?.lon, (typeof envData !== 'undefined' ? envData.lon : undefined)];

  function firstNum(arr){
    for (const v of arr) {
      if (v === undefined || v === null) continue;
      const n = Number(v);
      if (!Number.isNaN(n)) return n;
    }
    return null;
  }

  let lat = firstNum(latCandidates);
  let lon = firstNum(lonCandidates);

  // Fallback to map center if available
  try {
    if ((lat === null || lon === null) && typeof map !== 'undefined' && map && map.getCenter) {
      const c = map.getCenter();
      if (lat === null) lat = c.lat;
      if (lon === null) lon = c.lng;
    }
  } catch(e){}

  if (lat === null || lon === null) {
    primary.textContent = "Location needed";
    secondary.textContent = "Enable GPS or select favourite";
    return;
  }

  window.currentLat = lat;
  window.currentLon = lon;

  const now = new Date();
  const solFn = (typeof window.getSolunarWindows === 'function') ? window.getSolunarWindows : (typeof getSolunarWindows === 'function' ? getSolunarWindows : null);
  const sol = solFn ? solFn(now, lat, lon) : null;
  if (!sol) {
    primary.textContent = "Unavailable";
    secondary.textContent = "";
    return;
  }

  function fmt(t){ return t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }

  const windowsToday = [
    {label:"Major", start: sol.majorStart1, end: sol.majorEnd1},
    {label:"Major", start: sol.majorStart2, end: sol.majorEnd2},
    {label:"Minor", start: sol.minorStart1, end: sol.minorEnd1},
    {label:"Minor", start: sol.minorStart2, end: sol.minorEnd2},
  ].filter(w => w.start && w.end).sort((a,b)=>a.start-b.start);

  // Choose window: active > next today; if none, show next major tomorrow
  let chosen = windowsToday.find(w => now >= w.start && now <= w.end);
  let isActive = !!chosen;

  if (!chosen) chosen = windowsToday.find(w => w.start > now);

  let showingTomorrow = false;
  if (!chosen) {
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const sol2 = solFn ? solFn(tomorrow, lat, lon) : null;
    if (sol2) {
      const majorsTomorrow = [
        {label:"Major", start: sol2.majorStart1, end: sol2.majorEnd1},
        {label:"Major", start: sol2.majorStart2, end: sol2.majorEnd2},
      ].filter(w => w.start && w.end).sort((a,b)=>a.start-b.start);
      chosen = majorsTomorrow[0];
      showingTomorrow = true;
      isActive = false;
    }
  }

  if (!chosen) {
    primary.textContent = "Unavailable";
    secondary.textContent = "";
    return;
  }

  // Primary line
  if (isActive) {
    primary.textContent = chosen.label + " active";
  } else {
    const mins = Math.max(0, Math.round((chosen.start - now)/60000));
    primary.textContent = chosen.label + " in " + mins + " min";
  }

  // Stacked conditions (from other HUD cards)
  function parseMinutesToTurn() {
    const el = document.getElementById("hTideD") || document.getElementById("tideDetail");
    const txt = (el && el.textContent) ? el.textContent : "";
    const m1 = txt.match(/in\s+(\d+)\s*h\s*(\d+)\s*m/i);
    if (m1) return (parseInt(m1[1],10)*60 + parseInt(m1[2],10));
    const m2 = txt.match(/in\s+(\d+)\s*m/i);
    if (m2) return parseInt(m2[1],10);
    return null;
  }

  const stackLabels = [];
  let stackCount = 0;

  const minsToTurn = parseMinutesToTurn();
  if (minsToTurn !== null && minsToTurn <= 90) { stackLabels.push("Tide turn"); stackCount++; }

  const flowEl = document.getElementById("hFlowD") || document.getElementById("flowDetail");
  const flowTxt = (flowEl && flowEl.textContent) ? flowEl.textContent.toLowerCase() : "";
  if (flowTxt.includes("feeding zone")) { stackLabels.push("Flow"); stackCount++; }

  const pEl = document.getElementById("hPressD") || document.getElementById("pressureDetail");
  const pTxt = (pEl && pEl.textContent) ? pEl.textContent.toLowerCase() : "";
  if (pTxt.includes("stable") || pTxt.includes("rising")) { stackLabels.push("Pressure"); stackCount++; }

  // Trust stat: % of your catches here that occurred during solunar windows (in the currently selected intel range)
  function getCatchTimeMs(c){
    const v = c?.caughtAt ?? c?.timestamp ?? c?.createdAt;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function catchesAtCurrentSpot() {
    try{
      const portId = (envData?.id || envData?.portId || "").toString();
      const portName = (envData?.port || "").trim().toLowerCase();
      const at = (Array.isArray(catches) ? catches : []).filter(c => {
        const cid = (c.portId || c.idPort || c.stationId || '').toString();
        if (portId && cid && cid === portId) return true;
        const cl = (c.loc || '').trim().toLowerCase();
        return cl && portName && cl === portName;
      });
      if (typeof filterCatchesByIntelRange === "function") return filterCatchesByIntelRange(at);
      return at;
    }catch(e){ return []; }
  }

  function inAnyWindow(t, windows){
    for (const w of windows){
      if (!w?.start || !w?.end) continue;
      if (t >= w.start && t <= w.end) return true;
    }
    return false;
  }

  let trustTxt = "";
  try{
    const relevant = catchesAtCurrentSpot().map(c => getCatchTimeMs(c)).filter(v => v !== null);
    if (relevant.length >= 5) {
      let inCount = 0;
      for (const ms of relevant) {
        const dt = new Date(ms);
        const solC = solFn ? solFn(dt, lat, lon) : null;
        if (!solC) continue;
        const ws = [
          {start: solC.majorStart1, end: solC.majorEnd1},
          {start: solC.majorStart2, end: solC.majorEnd2},
          {start: solC.minorStart1, end: solC.minorEnd1},
          {start: solC.minorStart2, end: solC.minorEnd2},
        ];
        if (inAnyWindow(dt, ws)) inCount++;
      }
      const pct = Math.round((inCount / relevant.length) * 100);
      trustTxt = ` ‚Ä¢ ${pct}% of catches in solunar`;
    }
  } catch(e){ /* ignore */ }

  const baseSecondary = fmt(chosen.start) + "‚Äì" + fmt(chosen.end) + (showingTomorrow ? " (tomorrow)" : "");
  if (stackCount > 0) {
    const hot = (isActive && stackCount >= 2) ? " üî• " : " ";
    secondary.textContent = baseSecondary + trustTxt + " ‚Ä¢" + hot + stackLabels.join(" + ") + " (" + stackCount + "/3)";
  } else {
    secondary.textContent = baseSecondary + trustTxt;
  }

  // Visual emphasis when active
  if (biteTile && isActive) {
    biteTile.classList.add("is-active");
    if (stackCount >= 2) biteTile.classList.add("is-hot");
  }
}

  // Refresh once a minute, and also when app updates location/cards.
  window.updateBiteCard = updateBiteCard;
  try { updateBiteCard(); } catch(e) {}
  document.addEventListener("DOMContentLoaded", () => { try { updateBiteCard(); } catch(e) {} });
  setInterval(updateBiteCard, 60000);
})();
</script>


</body>
</html>
